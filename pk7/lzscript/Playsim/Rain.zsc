// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │   By Alison G. Watson. Attribution is encouraged, though not required.   │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

class Lith_RainThinker : Thinker;

Lith_WindThinker m_wind;
Actor            m_player;
class<Actor>     m_rainDrop;
float            m_visDist;
bool             m_rainSnd;
static Lith_RainThinker create() {
   bool         rainSnd;
   class<Actor> rainDrop;
   switch(Lith_UTIL.pData(_pdt_rain)) {
   default:          return null;
   case _rain_rain:  rainSnd = true;  rainDrop = 'Lith_RainDrop';      break;
   case _rain_blood: rainSnd = true;  rainDrop = 'Lith_BloodRainDrop'; break;
   case _rain_abyss: rainSnd = true;  rainDrop = 'Lith_AbyssRainDrop'; break;
   case _rain_fire:  rainSnd = false; rainDrop = 'Lith_Ash';           break;
   case _rain_snow:  rainSnd = false; rainDrop = 'Lith_SnowDrop';      break;
   }
   let th = new('Lith_RainThinker');
   th.m_wind     = Lith_HERMES.instance().m_wind;
   th.m_player   = players[consolePlayer].mo;
   th.m_rainSnd  = rainSnd;
   th.m_rainDrop = rainDrop;
   th.m_visDist  = 1.0;
   if(th.m_player && th.m_rainSnd) {
      th.m_player.A_StartSound("amb/rain", lch_weather2, CHANF_LOOP, 0.001, ATTN_NONE);
   }
   return th;
}
override void tick() {
   if(level.isFrozen() || level.time & 1) {
      return;
   }
   float tgtDist;
   float curDist = spawnRain();
   if(curDist == 0.0) {
      tgtDist = 0.0;
      if(m_player) {
         m_player.takeInventory('Lith_SMGHeat', 1);
      }
   } else {
      tgtDist = clamp(curDist / 1024.0, 0.0, 1.0);
   }
   m_visDist = Lith_UTIL.lerp(m_visDist, tgtDist, 0.035);
   if(m_player && m_rainSnd) {
      m_player.A_SoundVolume(lch_weather2, 1 - m_visDist);
   }
}
double spawnRain() const {
   let maxDist = m_rainSnd ? 2048 : 512;
   let mo      = m_player;
   if(!mo) {
      mo      = players[consoleplayer].camera;
      maxDist = m_rainSnd ? 8192 : 2048;
   }
   if(!mo || !mo.curSector) {
      return maxDist;
   }
   let raindist = 1024.0;
   let mpos     = mo.pos.xy;
   let maxh     = mo.pos.z + 768;
   if(mo.curSector.getTexture(Sector.ceiling) == skyFlatNum) {
      raindist = 0.0;
   }
   Sector lastSec = null;
   double zpos;
   for(int i = 0, j = maxDist/30; i < j; i++) {
      let pos = mpos + (fRandom[lith_rain](-maxDist, maxDist), fRandom[lith_rain](-maxDist, maxDist));
      let sec = level.pointInSector(pos);
      if(sec && sec.getTexture(Sector.CEILING) == skyFlatNum) {
         if(sec != lastSec) {
            zpos    = min(maxh, sec.findLowestCeilingPoint());
            lastSec = sec;
         }
         let rain = Actor.spawn(m_rainDrop, (pos, zpos - fRandom[lith_rain](0.0, 16.0)));
         rain.angle = m_wind.m_angle;
         rain.pitch = Lith_UTIL.constDeg(90.0 - m_wind.m_speed * 0.2);
         rain.vel  += m_wind.m_windVec * 0.1;
         if(m_rainSnd) {
            let dist = mo.distance2d(rain);
            if(dist < raindist) {
               raindist = dist;
            }
         }
      }
   }
   return raindist;
}

/* EOF */
