/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson. Attribution is encouraged, though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 */

class Lith_InventoryItem : Inventory abstract {
   default {
      Inventory.PickupMessage "";
      Inventory.PickupSound "";
      Lith_InventoryItem.InvEquip _cont_store;

      +INVENTORY.UNTOSSABLE
      +INVENTORY.UNDROPPABLE
      +CastSpriteShadow
   }

   uint   m_invEquip;
   string m_invName;
   uint   m_invSell;
   uint   m_invItem;

   string m_infoPage;

   int m_w, m_h;

   property InvEquip: m_invEquip;
   property InvName:  m_invName;
   property InvSell:  m_invSell;
   property Size:     m_w, m_h;
   property InfoPage: m_infoPage;

   bool Lith_OnBody() {return CallACS("Lith_ItemOnBody", m_invItem);}

   void Lith_Detach() {if(!self) return; m_invItem = 0; Destroy();}

   virtual bool Lith_UseItem(Actor mo) {return false;}
   virtual void Lith_OnAttach(Actor mo) {}

   virtual void Lith_Destroy() {
      if(m_invItem) {
         uint ip = m_invItem;
         m_invItem = 0;
         CallACS("Lith_ItemDetach", ip);
      }
   }

   private void Lith_CreateItem() {
      m_invItem = CallACS("Lith_ItemCreate", m_w, m_h, m_invEquip, m_invSell);
   }

   string Lith_GetName() {
      return StringTable.Localize("LITH_ITEM_TAG_" .. m_invName, false);
   }

   override Inventory CreateCopy(Actor mo) {
      let copy = Lith_InventoryItem(Super.CreateCopy(mo));

      if(copy != self) {
         copy.m_invName  = m_invName;
         copy.m_invSell  = m_invSell;
         copy.m_w        = m_w;
         copy.m_h        = m_h;
         copy.m_infoPage = m_infoPage;

         copy.setTag(Lith_GetName());
         copy.Lith_CreateItem();
      }

      return copy;
   }

   override bool HandlePickup(Inventory item) {return false;}

   override void PostBeginPlay() {
      Super.PostBeginPlay();
      setTag(Lith_GetName());
      Lith_CreateItem();
   }

   override void AttachToOwner(Actor mo) {
      let id = Lith_IDOL(mo.FindInventory("Lith_IDOL"));
      if(id.Lith_Attach(m_invItem)) {
         if(m_infoPage) Lith_HERMES.UnlockBip(mo, m_infoPage);
         Lith_OnAttach(mo);
      }
      Super.AttachToOwner(id);
   }

   override bool CanPickup(Actor mo) {
      if(Super.CanPickup(mo)) {
         let id = Lith_IDOL(mo.FindInventory("Lith_IDOL"));
         return m_invItem && id && id.Lith_SpaceFree(m_invItem);
      } else {
         return false;
      }
   }

   override bool TryPickup(in out Actor mo) {
      if(Super.TryPickup(mo)) {
         Lith_HERMES.Log(mo, msg_both, 3, Lith_GetName());
         return true;
      } else {
         return false;
      }
   }
}

class Lith_BasicPickup : Inventory {
   default {
      Inventory.PickupMessage "";
      Inventory.PickupSound "";
      Lith_BasicPickup.LogType msg_both;
      +INVENTORY.TRANSFER
      +CastSpriteShadow
   }

   private meta string m_LogName;
   private meta int    m_LogType;
   private meta int    m_LogLevl;

   private int m_Flags;

   string m_InfoPage;

   property  LogName: m_LogName, m_LogLevl;
   property  LogType: m_LogType;
   property InfoPage: m_InfoPage;

   flagdef Vacuum: m_Flags, 0;

   virtual void Lith_OnPickup(Actor mo) {
      if(m_LogName)
         Lith_HERMES.Log(mo, m_LogType, m_LogLevl, "_" .. m_LogName);
      if(m_InfoPage)
         Lith_HERMES.UnlockBip(mo, m_InfoPage);
   }

   override bool TryPickup(in out Actor mo) {
      Lith_OnPickup(mo);
      GoAwayAndDie();
      return true;
   }
}

/* IDOL: Inventory Dummies are Overly Luxurious */
class Lith_IDOL : Inventory;

default {
   +INVENTORY.KEEPDEPLETED
   +INVENTORY.UNTOSSABLE
   +INVENTORY.UNDROPPABLE
}

Lith_InventoryItem Lith_Find(uint ip) {
   for(Inventory it = inv; it; it = it.inv) {
      if(it.Owner == self && it is "Lith_InventoryItem") {
         let item = Lith_InventoryItem(it);
         if(item.m_invItem == ip)
            return item;
      }
   }

   return null;
}

bool Lith_Attach(uint ip)
   {return owner && owner.ACS_ScriptCall("Lith_ItemAttach", ip);}

bool Lith_SpaceFree(uint ip)
   {return owner && owner.ACS_ScriptCall("Lith_ItemCanPlace", ip);}

void Lith_Remove(uint ip) {
   let it = Lith_Find(ip);
   it.Lith_Detach();
}

bool Lith_Use(uint ip) {
   let it = Lith_Find(ip);
   return it.Lith_UseItem(owner);
}

/* EOF */
