class Lith_Cyberspace;

// pixel texture
TextureID m_ptex;

// pixel buffer
const m_rw = 64;
const m_rh = 48;

uint8 m_dbuf[m_rw * m_rh];

// map (TODO: make dynamic)
const m_mw = 8;
const m_mh = 8;

static const uint8[] m_map = {
   1, 1, 1, 1, 1, 1, 1, 1,
   1, 0, 0, 0, 0, 0, 0, 1,
   1, 0, 1, 0, 0, 1, 0, 1,
   1, 0, 0, 0, 0, 1, 0, 1,
   1, 0, 1, 0, 0, 0, 0, 1,
   1, 0, 1, 0, 0, 1, 0, 1,
   1, 0, 0, 0, 0, 0, 0, 1,
   1, 1, 1, 1, 1, 1, 1, 1
};

// camera normal
double m_nx;
double m_ny;

// camera plane
double m_px;
double m_py;

// view pos
int m_vx;
int m_vy;

static Lith_Cyberspace CreateDerived(class<Lith_Cyberspace> type)
{
   let cs = Lith_Cyberspace(new(type));

   cs.m_ptex = TexMan.CheckForTexture("lgfx/Pixel.png", 0);

   cs.m_nx = -1.0;
   cs.m_ny =  0.0;

   cs.m_px = 0.0;
   cs.m_py = 0.66;

   cs.m_vx = 4;
   cs.m_vy = 4;

   return cs;
}

static Lith_Cyberspace Create()
{
   return CreateDerived("Lith_Cyberspace");
}

void Lith_RotateView(double rel)
{
   double o_nx = m_nx;
   double o_px = m_px;

   // rotate normal and plane with a simple matrix
   m_nx = m_nx * cos(rel) - m_ny * sin(rel);
   m_ny = o_nx * sin(rel) + m_ny * cos(rel);
   m_px = m_px * cos(rel) - m_py * sin(rel);
   m_py = o_px * sin(rel) + m_py * cos(rel);
}

virtual void Lith_DrawFrame()
{
   for(int x = 0; x < m_rw; x++)
   {
      // camera x coordinate
      double ndc = (x / double(m_rw)) * 2 - 1;
      if(ndc == 0) ndc = 0.001; // hack to prevent sigfpe

      // ray normal
      double rnx = m_nx + m_px * ndc;
      double rny = m_ny + m_py * ndc;

      // direction delta
      double ddx = sqrt(1.0 + (rny * rny) / (rnx * rnx));
      double ddy = sqrt(1.0 + (rnx * rnx) / (rny * rny));

      // distance to side
      double sidedx;
      double sidedy;

      // step sign
      int stepx;
      int stepy;

      // get direction for ray normal
      if(rnx < 0) {stepx = -1; sidedx = 0;}
      else        {stepx =  1; sidedx = ddx;}
      if(rny < 0) {stepy = -1; sidedy = 0;}
      else        {stepy =  1; sidedy = ddy;}

      // dda raycast
      int mapx = m_vx;
      int mapy = m_vy;

      bool side = false;

      do {
         if(sidedx < sidedy) {sidedx += ddx; mapx += stepx; side = false;}
         else                {sidedy += ddy; mapy += stepy; side = true; }
      } while(!m_map[mapx + mapy * m_mw]);

      // get perspective distance
      double pwdst;
      if(side) pwdst = (mapy - m_vy + (1 - stepy) / 2) / rny;
      else     pwdst = (mapx - m_vx + (1 - stepx) / 2) / rnx;

      // get line draw properties
      int lineh = m_rh / pwdst;

      int ds = -lineh / 2 + m_rh / 2;
      int de =  lineh / 2 + m_rh / 2;

      if(ds < 0) ds = 0;
      if(de >= m_rh) de = m_rh - 1;

      if(ds == de) continue;

      // get light amount for line
      int light = 0xFF - (pwdst * 32);
      if(side) light /= 2;
      if(light <  32) light = 32;
      if(light > 135) light = 135;

      // clear and draw line
      for(int y =  0; y <  m_rh; y++) m_dbuf[x + y * m_rw] = 0;
      for(int y = ds; y <= de; y++) m_dbuf[x + y * m_rw] = light;
   }
}

virtual ui void Lith_Render() const
{
   // color shifts
   static const int[] shifts = {0, 2, 8, 10, 16, 18};
   int shift = shifts[level.totaltime / 35 % 6];

   Screen.Dim("Black", 1, 0, 0, Screen.GetWidth(), Screen.GetHeight());

   // draw scene from pixel buffer
   for(int y = 0; y < m_rh; y++)
      for(int x = 0; x < m_rw; x++)
   {
      Screen.DrawTexture(m_ptex, false, x, y,
         DTA_VirtualWidth,  m_rw,
         DTA_VirtualHeight, m_rh,
         DTA_FillColor,     m_dbuf[x + y * m_rw] << shift);
   }
}

// EOF
