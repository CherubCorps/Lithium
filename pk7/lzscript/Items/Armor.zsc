enum Lith_ArmorSlot
{
   slot_lower,
   slot_upper,
   slot_ring,
   slot_pauld,
   slot_max
}

// AAGH: Armors Are Goddamn Heavy
class Lith_AAGH : Inventory
{
   default
   {
      +INVENTORY.KEEPDEPLETED
      +INVENTORY.UNTOSSABLE
      +INVENTORY.UNDROPPABLE
   }

   Lith_Armor lith_slotted[slot_max];

   static Lith_DamageType Lith_NameToDT(name type)
   {
      switch(type)
      {
      default:
      case 'Bullet':
      case 'Lith_Bullets':   return ldt_bullets;
      case 'Plasma':
      case 'Railgun':
      case 'Electric':
      case 'Lith_Energy':    return ldt_energy;
      case 'Fire':
      case 'Lith_Fire':      return ldt_fire;
      case 'FireMagic':
      case 'Lith_FireMagic': return ldt_firemagic;
      case 'Magic':
      case 'Lith_Magic':     return ldt_magic;
      case 'Shrapnel':
      case 'Explosion':
      case 'Lith_Shrapnel':  return ldt_shrapnel;
      case 'Ice':
      case 'Lith_Ice':       return ldt_ice;
      }
   }

   bool Lith_CheckSlot(Lith_Armor o)
   {
      let slot = o.Lith_Slot();
      return slot >= 0 && slot < slot_max && !lith_slotted[slot];
   }

   bool Lith_AddSlot(Lith_Armor o)
   {
      if(!Lith_CheckSlot(o))
         return false;

      let slot = o.Lith_Slot();

      lith_slotted[slot] = o;

      Console.printf("%p: slotted: %i %s", self, slot, o.getClassName());

      return true;
   }

   bool Lith_RemoveSlot(int slot)
   {
      if(slot < 0 || slot >= slot_max || !lith_slotted[slot])
         return false;

      RemoveInventory(lith_slotted[slot]);
      lith_slotted[slot] = null;

      return true;
   }

   override void AbsorbDamage(int damage, name type, out int newdamage)
   {
      if(DamageTypeDefinition.IgnoreArmor(type)) return;

      int save = 0;

      for(int i = 0; i < slot_max; i++)
         if(lith_slotted[i])
            save += lith_slotted[i].Lith_SaveAmt(type);

      if(damage - save < 1) newdamage = 1;
      else                  newdamage = damage - save;

      Console.printf("DT save: (%s) %i (%i -> %i)", type, save, damage, newdamage);
   }
}

class Lith_Armor : Armor
{
   protected int lith_slotnum;

   private int lith_save0;
   private int lith_save1;

   protected int lith_cursave;

   property SlotSave: lith_slotnum, lith_save0, lith_save1;

   virtual int Lith_Slot()
      {return lith_slotnum;}

   virtual int Lith_SaveAmt(name type)
      {return lith_cursave;}

   override Inventory CreateCopy(Actor mo)
   {
      let copy = Lith_Armor(Super.CreateCopy(mo));

      copy.lith_slotnum = lith_slotnum;
      copy.lith_save0   = lith_save0;
      copy.lith_save1   = lith_save1;
      copy.lith_cursave = lith_cursave;

      return copy;
   }

   override bool CanPickup(Actor mo)
   {
      if(Super.CanPickup(mo))
      {
         let a = Lith_AAGH(mo.findInventory("Lith_AAGH"));
         return a && a.Lith_CheckSlot(self);
      }
      else
         return false;
   }

   override bool TryPickup(in out Actor mo)
   {
      let a = Lith_AAGH(mo.findInventory("Lith_AAGH"));

      if(a)
      {
         let copy = Lith_Armor(CreateCopy(a));

         if(copy && a.Lith_AddSlot(copy))
         {
            copy.attachToOwner(a);
            return true;
         }
         else if(copy != self)
            copy.destroy();
      }

      return false;
   }

   override void BeginPlay()
   {
      Super.BeginPlay();
      lith_cursave = lith_save0;
   }
}

class Lith_Armor_Resistant : Lith_Armor
{
   protected int lith_resist;

   property Resist: lith_resist;

   override Inventory CreateCopy(Actor mo)
   {
      let copy = Lith_Armor_Resistant(Super.CreateCopy(mo));

      copy.lith_resist = lith_resist;

      return copy;
   }

   override int Lith_SaveAmt(name type)
   {
      let dt = Lith_AAGH.Lith_NameToDT(type);
      return lith_resist == dt ? lith_cursave * 2 : lith_cursave;
   }
}

class Lith_Armor_Standard_Upper : Lith_Armor
{
   default
   {
      Lith_Armor.SlotSave slot_upper, 2, 3;
   }

   states {Spawn: ARM1 A -1; stop;}
}

class Lith_Armor_Standard_Lower : Lith_Armor
{
   default
   {
      Lith_Armor.SlotSave slot_lower, 1, 2;
   }

   states {Spawn: ARM1 B -1; stop;}
}

class Lith_Armor_Improved_Upper : Lith_Armor
{
   default
   {
      Lith_Armor.SlotSave slot_upper, 3, 4;
   }

   states {Spawn: ARM2 A -1; stop;}
}

class Lith_Armor_Improved_Lower : Lith_Armor
{
   default
   {
      Lith_Armor.SlotSave slot_lower, 2, 3;
   }

   states {Spawn: ARM2 B -1; stop;}
}

class Lith_Armor_Teflon_Upper : Lith_Armor_Resistant
{
   default
   {
      Lith_Armor.SlotSave slot_upper, 3, 4;
      Lith_Armor_Resistant.Resist ldt_energy;
   }

   states {Spawn: ARM2 A -1; stop;}
}

class Lith_Armor_Teflon_Lower : Lith_Armor_Resistant
{
   default
   {
      Lith_Armor.SlotSave slot_lower, 1, 2;
      Lith_Armor_Resistant.Resist ldt_energy;
   }

   states {Spawn: ARM2 B -1; stop;}
}

class Lith_Armor_Dendrite_Upper : Lith_Armor_Resistant
{
   default
   {
      Lith_Armor.SlotSave slot_upper, 3, 4;
      Lith_Armor_Resistant.Resist ldt_fire;
   }

   states {Spawn: ARM2 A -1; stop;}
}

class Lith_Armor_Dendrite_Lower : Lith_Armor_Resistant
{
   default
   {
      Lith_Armor.SlotSave slot_lower, 1, 2;
      Lith_Armor_Resistant.Resist ldt_fire;
   }

   states {Spawn: ARM2 B -1; stop;}
}

class Lith_Armor_HazMat : Lith_Armor
{
   override int Lith_SaveAmt(name type)
      {return Lith_HERMES.Instance().lith_dmg_world ? 10 : lith_cursave;}
}

class Lith_Armor_HazMat_Upper : Lith_Armor_HazMat
{
   default
   {
      Lith_Armor.SlotSave slot_upper, 2, 3;
   }

   states {Spawn: ARM2 A -1; stop;}
}

class Lith_Armor_HazMat_Lower : Lith_Armor_HazMat
{
   default
   {
      Lith_Armor.SlotSave slot_lower, 1, 2;
   }

   states {Spawn: ARM2 B -1; stop;}
}

class Lith_GreenArmor : Lith_RandomSpawn replaces GreenArmor
{
   default
   {
      Lith_RandomSpawn.SpawnNum lrsn_greenarmor;
   }
}

class Lith_BlueArmor : Lith_RandomSpawn replaces BlueArmor
{
   default
   {
      Lith_RandomSpawn.SpawnNum lrsn_bluearmor;
   }
}

// EOF
