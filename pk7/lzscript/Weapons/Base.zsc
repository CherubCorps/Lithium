/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson. Attribution is encouraged, though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 */

class Lith_WeaponScopedToken : Inventory {default {Inventory.MaxAmount 1;}}

class Lith_Weapon : Weapon;

enum Lith_PSprite {
   _psp_weapon = psp_weapon,
   _psp_double_lg,
   _psp_double_rg,
   _psp_wep_max,

   _psp_flash = psp_flash,
   _psp_double_lf,
   _psp_double_rf,
   _psp_d_subweapon,
   _psp_flash_max,

   _psp_overlay_hax = 69420,

}

enum Lith_Hand {
   _rhs,
   _lhs,
}

enum Lith_Oscillate {
   _no_oscill,
   _oscillate,
}

enum Lith_TracerType {
   _tr_normal,
   _tr_slow,
   _tr_none
}

enum Lith_RaiseSpeed {
   _raise_slow,
   _raise_normal,
   _raise_fast,
   _raise_instant
}

default {
   Inventory.PickupMessage "";
   Inventory.PickupSound "";
   Lith_Weapon.ScopeInSound "weapons/shotgun/zoomin";
   Lith_Weapon.ScopeOutSound "weapons/shotgun/zoomout";
   Lith_Weapon.ScopeZoom 1.0;
   Weapon.BobSpeed 1.5;
   Weapon.BobStyle "InverseSmooth";

   +INVENTORY.UNTOSSABLE;
   +WEAPON.NOALERT;
}

int m_fired;
int m_max;
int m_firePattern;

private meta sound m_scopeOutSnd;
private meta sound m_scopeInSnd;
private meta double m_scopeZoom;

private meta class<Actor> m_spawnType;

private bool m_side;

private readOnly uint m_lithWeaponFlags;

property MagSize: m_max;

property ScopeOutSound: m_scopeOutSnd;
property ScopeInSound:  m_scopeInSnd;
property ScopeZoom:     m_scopeZoom;

property SpawnType: m_spawnType;

flagDef Slot3OptAmmo: m_lithWeaponFlags, 0;

const _psp_flags =
   PSPF_ADDWEAPON | PSPF_ADDBOB | PSPF_ALPHA | PSPF_RENDERSTYLE;

virtual double, double GetFirePattern() {
   return 0, 0;
}

virtual state Lith_Ready(int flags) {
   return null;
}

override void tick() {
   super.tick();

   if(bSlot3OptAmmo) {
      if(Lith_UTIL.pData(owner, pdata_slot3Ammo)) {
         if(!ammoType1) {
            ammoType1 = "Lith_ShellAmmo";
            ammo1     = addAmmo(owner, ammoType1, 0);
         }
      } else {
         if(ammoType1) {
            ammoType1 = null;
            ammo1     = null;
         }
      }
   }
}

int lith_getRaiseSpeed(Lith_RaiseSpeed speed) {
   switch(speed) {
   case _raise_slow:    return 10;
   case _raise_normal:  return 12;
   case _raise_fast:    return 18;
   case _raise_instant: return 60;
   default:             throwAbortException("invalid raise speed");
   }
   return 0;
}

action(Weapon) void lith_a_setInterpolation(bool on) {
   for(int psp = _psp_weapon; psp < _psp_wep_max; ++psp) {
      a_overlayFlags(psp, pspf_interpolate, on);
   }
}

action(Weapon) void lith_a_overlayTick() {
   float a;
   int style;

   if(countInv("Lith_WeaponScopedToken")) {
      a = CVar.getCVar('lith_weapons_scopealpha', player).getFloat();
      style = style_subtract;
   } else {
      a = CVar.getCVar('lith_weapons_alpha', player).getFloat();
      style = style_translucent;
   }

   a *= Lith_UTIL.pData(self, pdata_alpha) / FIX;

   for(int psp = _psp_weapon;; ++psp) {
      if(psp == _psp_wep_max) {
         psp = _psp_flash;
      } else if(psp == _psp_flash_max) {
         break;
      }

      a_overlayFlags(psp, pspf_alpha|pspf_renderstyle, true);
      a_overlayRenderStyle(psp, style);
      a_overlayAlpha(psp, a);

      if(Lith_Player(self).m_wasDamaged) {
         a_overlayTranslation(psp, "Lith_FuckUp" .. random(1, 4));
      } else {
         a_overlayTranslation(psp, '');
      }
   }
}

action(Weapon) void Lith_A_Lower(Lith_RaiseSpeed speed) {
   if(!player) {
      return;
   }

   if(!player.readyWeapon) {
      lith_a_setInterpolation(false);
      player.mo.bringUpWeapon();
      return;
   }

   int lowerSpeed = invoker.lith_getRaiseSpeed(speed);
   let psp = player.getPSprite(_psp_weapon);
   if(psp) {
      lith_a_setInterpolation(true);

      if(player.morphTics || player.cheats & cf_instantweapswitch) {
         psp.y = weaponBottom;
      } else {
         psp.y += lowerSpeed;
      }

      if(psp.y < weaponBottom) {
         return;
      }

      resetPSprite(psp);
      if(player.playerState == pst_dead) {
         lith_a_setInterpolation(false);
         player.setPSprite(_psp_flash, null);
         psp.setState(findState('DeadLowered'));
         return;
      }

      lith_a_setInterpolation(false);
      player.setPSprite(_psp_flash, null);
      player.mo.bringUpWeapon();
   }
}

action(Weapon) void Lith_A_Raise(Lith_RaiseSpeed speed) {
   if(!player) {
      return;
   }

   if(player.pendingWeapon != WP_NOCHANGE) {
      player.mo.dropWeapon();
      return;
   }

   if(!player.readyWeapon) {
      return;
   }

   int raiseSpeed = invoker.lith_getRaiseSpeed(speed);
   let psp = player.getPSprite(_psp_weapon);
   if(psp) {
      A_Overlay(_psp_overlay_hax, "_MultithreadedFuckingOverlaysBecauseGodIsDeadAndGrafZahlKilledHim");

      if(psp.y <= weaponBottom) {
         resetPSprite(psp);
      }

      psp.y -= raiseSpeed;
      if(psp.y > weaponTop) {
         return;
      }
      psp.y = weaponTop;

      psp.setState(invoker.getReadyState());
   }
}

action(Weapon) state Lith_A_DoubleReady() {
   if(health < 1) return resolveState("Null");
   else           return null;
}

action(Weapon) void Lith_A_DoubleRaise() {
   A_Overlay(_psp_double_lg, "ReadyLH");
   A_Overlay(_psp_double_rg, "ReadyRH");
   A_OverlayFlags(_psp_double_lg, _psp_flags, true);
   A_OverlayFlags(_psp_double_rg, _psp_flags, true);
}

action(Weapon) void Lith_A_DoubleState(bool oscillate, statelabel lh, statelabel rh) {
   if(oscillate) {
      invoker.m_side = !invoker.m_side;
      if(invoker.m_side) A_Overlay(_psp_double_lg, lh);
      else               A_Overlay(_psp_double_rg, rh);
   } else {
      A_Overlay(_psp_double_lg, lh);
      A_Overlay(_psp_double_rg, rh);
   }
}

action(Weapon) void Lith_A_DoubleOffset(bool left, int x, int y) {
   int fst = left ? _psp_double_lg : _psp_double_rg;
   int snd = left ? _psp_double_lf : _psp_double_rf;
   A_OverlayOffset(fst, x, y);
   A_OverlayOffset(snd, x, y);
}

action(Weapon) state Lith_A_Ready(int flags = 0) {
   if(!countInv("Lith_WeaponScopedToken")) {
      a_zoomFactor(1.0, ZOOM_INSTANT);
   }

   let st = invoker.lith_ready(flags);
   if(st) {
      return st;
   } else {
      a_weaponReady(flags | callACS("Lith_GetWRF"));
      return null;
   }
}

action(Actor) void Lith_A_SpawnPickup(class<Actor> a) {
}

bool Lith_MagEmpty() {
   return m_fired >= m_max;
}

virtual void Lith_ReloadFinish(bool isauto) {
   m_fired = 0;
}

action(Weapon) state Lith_A_JumpIfMagEmpty(bool autoreload = true, statelabel rsn = "Reload", statelabel esn = "FireEmpty") {
   statelabel sn;
   if(autoreload) {
      if(CVar.GetCVar('lith_weapons_reloadempty', Player).GetBool()) {
         sn = rsn;
      } else {
         sn = esn;
      }
   } else {
      sn = rsn;
   }
   if(invoker.lith_magEmpty()) {
      if(sn == "FireEmpty") {
         lith_a_setInterpolation(true);
      }
      return ResolveState(sn);
   } else {
      return null;
   }
}

action(Weapon) state Lith_A_JumpIfMagFull(statelabel sn = "ReadySelector") {
   return invoker.m_fired ? null : ResolveState(sn);
}

action(Weapon) void Lith_A_MagIncr(int amt = 1) {
   if(!Lith_UTIL.pData(self, pdata_upgrade, UPGR_OneShot))
      invoker.m_fired = min(invoker.m_fired + amt, invoker.m_max);
   else
      invoker.m_fired = invoker.m_max;
}

action(Weapon) void Lith_A_ReloadFinish() {
   invoker.Lith_ReloadFinish(false);
}

action(Weapon) void Lith_A_RecoilUp(double amt) {
   double v = CVar.GetCVar('lith_weapons_recoil', Player).GetFloat() * amt;
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_RecoilDn(double amt) {
   double v = CVar.GetCVar('lith_weapons_recoil', Player).GetFloat() * (-amt/4);
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_ReloadBobUp(double amt) {
   double v = CVar.GetCVar('lith_weapons_reloadbob', Player).GetFloat() * amt;
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_ReloadBobDn(double amt) {
   double v = CVar.GetCVar('lith_weapons_reloadbob', Player).GetFloat() * -amt;
   CallACS("Lith_RecoilUp", int(v * FIX));
}

action(Weapon) void Lith_A_ScopeIn() {
   if(!CountInv("Lith_WeaponScopedToken")) {
      self.GiveInventory("Lith_WeaponScopedToken", 1);
      A_ZoomFactor((1+Lith_UTIL.pData(self, pdata_weaponzoom)/FIX)*invoker.m_scopeZoom);
      A_StartSound(invoker.m_scopeInSnd, lch_scope);
   }
}

action(Weapon) void Lith_A_ScopeOut() {
   if(CountInv("Lith_WeaponScopedToken")) {
      self.TakeInventory("Lith_WeaponScopedToken", 1);
      A_ZoomFactor(1.0, ZOOM_INSTANT);
      A_StartSound(invoker.m_scopeOutSnd, lch_scope);
   }
}

action(Weapon) void Lith_A_ScopeToggle() {
   if(CountInv("Lith_WeaponScopedToken")) Lith_A_ScopeOut();
   else                                   Lith_A_ScopeIn();
}

action(Weapon) void Lith_A_ZoomFactorScoped(double amount) {
   A_ZoomFactor((1+Lith_UTIL.pData(self, pdata_weaponzoom)/FIX) * amount * invoker.m_scopeZoom);
}

action(Weapon) void Lith_GunSmoke(class<Actor> type, double x, double y, bool ignoreCrouch) {
   if(!ignoreCrouch) (y -= ((1.0 - GetCrouchFactor(AAPTR_DEFAULT)) * 10.0));
   A_FireProjectile(type, 0, 0, x, y, FPF_NOAUTOAIM);
}

action(Weapon) void Lith_A_GunSmoke(double x = 0, double y = 6, bool ignoreCrouch = false) {
   Lith_GunSmoke("Lith_GunSmokeSpawner", x, y, ignoreCrouch);
}

action(Weapon) void Lith_A_GunSmokeSmall(double x = 0, double y = 6, bool ignoreCrouch = false) {
   Lith_GunSmoke("Lith_GunSmokeSpawnerSmall", x, y, ignoreCrouch);
}

action(Weapon) void Lith_A_DropMag(class<Lith_DroppedMagazine> mag1, class<Lith_DroppedMagazine> mag2, double px, double py, double pz, double vx, double vy, double vz) {
   double vh = Player.ViewZ - Player.MO.ViewHeight - Pos.Z;
   px += FRandom(-1, 1); py += FRandom(-1, 1); pz += FRandom(-1, 1);
   vx += FRandom(-1, 1); vy += FRandom(-1, 1); vz += FRandom(-1, 1);
   A_SpawnItemEx(invoker.Lith_MagEmpty() || !mag2 ? mag1 : mag2, px,py,pz+vh, vx,vy,vz);
}

action(Weapon) void Lith_A_Casing(class<Lith_CasingBase> cas, double px, double py, double pz, double vx, double vy, double vz) {
   double vh = Player.ViewZ - Player.MO.ViewHeight - Pos.Z;
   px += FRandom(-1, 1); py += FRandom(-1, 1); pz += FRandom(-1, 1);
   vx += FRandom(-1, 1); vy += FRandom(-1, 1); vz += FRandom(-1, 1);
   A_SpawnItemEx(cas, Cos(Pitch)*px, py, pz-Sin(Pitch)*px+vh, vx, vy, vz);
}

action(Weapon) void Lith_FixedBullets(int numBullets, int damage, int flags = 0, class<Actor> puffType = "Lith_BulletPuff", double tracerX = 0, double range = 8192) {
   for(int i = 0; i < numBullets; i++) {
      double p, y; [p, y] = invoker.GetFirePattern();
      Lith_FireBullets(p, y, -1, damage, FBF_EXPLICITANGLE | FBF_NORANDOM | flags, puffType, tracerX, range);
   }
}

action(Weapon) void Lith_FireBullets(double spreadHorz, double spreadVert, int numBullets, int damage, int flags = 0, class<Actor> puffType = "Lith_BulletPuff", double tracerX = 0, double range = 8192, Lith_TracerType tracer = _tr_normal) {
   class<Actor> tracerType;
   switch(tracer) {
   default:
   case _tr_normal: tracerType = "Lith_BulletTracer";     break;
   case _tr_slow:   tracerType = "Lith_BulletTracerSlow"; break;
   case _tr_slow:   tracerType = null;                    break;
   }
   A_FireBullets(spreadHorz, spreadVert, numBullets, damage, puffType, flags, range, tracerType, 7 + FRandom(-1, 0), tracerX + FRandom(-0.7, 0.7));
}

action(Weapon) State lith_jumpNoAmmo(int minAmount = 1, stateLabel label = "FireEmpty") {
   if(invoker.ammoType1 && self.countInv(invoker.ammoType1) < minAmount) {
      if(label == "FireEmpty") {
         lith_a_setInterpolation(true);
      }
      return resolveState(label);
   } else {
      return null;
   }
}

action(Weapon) void lith_takeAmmo(int amount = 1) {
   self.takeInventory(invoker.ammoType1, amount, noTakeInfinite: true);
}

action(Weapon) State lith_jumpAmmo(int maxAmount, stateLabel label) {
   if(self.countInv(invoker.ammoType1) >= maxAmount) {
      return resolveState(label);
   } else {
      return null;
   }
}

action(Weapon) clearScope int lith_maxInv(class<Inventory> itemType) {
   let item = findInventory(itemType);
   if(item) {
      return item.maxAmount;
   } else {
      return getDefaultByType(itemType).maxAmount;
   }
}

states(Actor) {
Spawn:
   TNT1 A 0;
   TNT1 A 0 {
      /* UDMF maps have a surprising amount of control over things, so we
       * have to use a load of flags to make this work properly.
       */
      if(!bDROPPED && m_spawnType)
         A_SpawnItemEx(m_spawnType, flags:
                       SXF_TRANSFERTRANSLATION | SXF_TRANSFERAMBUSHFLAG  |
                       SXF_TRANSFERPITCH       | SXF_TRANSFERPOINTERS    |
                       SXF_TRANSFERSCALE       | SXF_TRANSFERSPECIAL     |
                       SXF_TRANSFERSTENCILCOL  | SXF_TRANSFERALPHA       |
                       SXF_TRANSFERRENDERSTYLE | SXF_TRANSFERSPRITEFRAME |
                       SXF_TRANSFERROLL);
   }
   stop;
}

states(Weapon) {
_MultithreadedFuckingOverlaysBecauseGodIsDeadAndGrafZahlKilledHim:
   TNT1 A 1 lith_a_overlayTick();
   loop;
ReadySelector:
   #### # 0 {
      lith_a_setInterpolation(false);
      return CountInv("Lith_WeaponScopedToken") ? ResolveState("AltReady")
                                                : ResolveState("Ready");
   }
   stop;
DummyFlash:
   TNT1 A 0 A_AlertMonsters;
   stop;
}

/* EOF */
