/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson & InsanityBringer. Attribution is encouraged,
 * though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 */

/* UTIL: Utilities and Tools Interpserse Languages */
struct Lith_UTIL
{
   /* fucking degrees system... */
   static double constDeg(double x)
   {
      x %= 360;
      if(x < 0) x += 360;
      return x;
   }

   static double diffDeg(double a, double b)
   {
      double d = (b - a) % 360;
      if(d < 0) d += 360;
      return d;
   }

   static double sDiffDeg(double a, double b)
   {
      double d = b - a;
      if(d ~== 0) return 0;
      d %= 360;
      return 2 * d % 360 - d;
   }

   static double angleLerp(double a, double b, double t)
   {
      return a + SDiffDeg(a, b) * t;
   }

   static double lerp(double a, double b, double t)
   {
      return (1 - t) * a + t * b;
   }

   static vector2 vec2Lerp(vector2 a, vector2 b, double t)
   {
      let vec = (Lerp(a.x, b.x, t), Lerp(a.y, b.y, t));
      return vec;
   }

   static vector3 vec3Lerp(vector3 a, vector3 b, double t)
   {
      let vec = (Lerp(a.x, b.x, t), Lerp(a.y, b.y, t), Lerp(a.z, b.z, t));
      return vec;
   }

   static int round(double n)
   {
      return int(n * 1000) % 1000 < 500 ? int(n) : int(n+0.5);
   }

   static vector3 traceFrom(Actor mo, double yaw, double pitch, double dist, double offsetz, bool floor = false, bool portalAware = true, ETraceFlags flags = 0) {
      return Lith_HERMES.instance().traceFromActor(mo, yaw, pitch, dist, offsetZ, floor, portalAware, flags);
   }

   static vector3 traceFromPos(Sector sec, vector3 pos, double yaw, double pitch, double dist, Actor ignore = null, bool floor = false, bool portalAware = true, ETraceFlags flags = 0) {
      return Lith_HERMES.instance().traceFromPos(sec, pos, yaw, pitch, dist, ignore, floor, portalAware, flags);
   }

   static play int exec(Actor mo, int scr, int arg0 = 0, int arg1 = 0, int arg2 = 0, int arg3 = 0) {
      return Level.ExecuteSpecial(84, mo, null, false, scr, arg0, arg1, arg2, arg3);
   }

   static play int pData(Actor ply, int info, int permutation = 0) {
      return Level.ExecuteSpecial(84, ply, null, false, lsc_pdata, info, permutation);
   }

   static play void stateTick(Actor mo) {
      if(mo.tics >= 0 && --mo.tics <= 0) {
         mo.setState(mo.curState.nextState);
      }
   }
}

/* UTILHACK: Urinary Tract Infection-Like Hack (Anal Cock King ed.) */
class Lith_UTILHACK {
   play int exec(Actor mo, int scr, int arg0 = 0, int arg1 = 0, int arg2 = 0, int arg3 = 0) const {
      return Lith_UTIL.exec(mo, scr, arg0, arg1, arg2, arg3);
   }

   play int pData(Actor ply, int info, int permutation = 0) const {
      return Lith_UTIL.pData(ply, info, permutation);
   }
}

class Lith_LineTracer : LineTracer {
   Actor m_Ignore;

   override ETraceStatus traceCallback() {
      if(results.hitActor == m_Ignore) {
         return TRACE_Skip;
      } else {
         return TRACE_Stop;
      }
   }
}

/* EOF */
