#!/usr/bin/env ruby
## Copyright Â© 2017 Alison Sanderson, all rights reserved.
## WepC: Weapon info text compiler.

def outHeader fp, weps
   fp.puts <<_end_
// zsc output: pk7/lzscript/Headers/lith_weapons.h

// This file was generated by wepc.
// Edit only if you aren't going to recompile.

enum // WeaponNum
{
   weapon_min = 1,
   weapon_unknown = 0,

#{
   ret = ""
   for wep in weps
      ret += "   #{wep.nam},\n"
   end
   ret
}
   weapon_max
};

enum // WeaponName
{
   wepnam_fist,
   wepnam_chainsaw,
   wepnam_pistol,
   wepnam_shotgun,
   wepnam_supershotgun,
   wepnam_chaingun,
   wepnam_rocketlauncher,
   wepnam_plasmarifle,
   wepnam_bfg9000,

   wepnam_max,
};

enum // RifleMode
{
   rifle_firemode_auto,
   rifle_firemode_grenade,
   rifle_firemode_burst,
   rifle_firemode_max
};

// EOF
_end_
end

def outSource fp, weps, wepn
   fp.puts <<_end_
// This file was generated by wepc.
// Edit only if you aren't going to recompile.
#if LITHIUM
#include "lith_common.h"
#include "lith_player.h"

StrEntON

// Extern Objects ------------------------------------------------------------|

#define Placeholder1 "MMMMHMHMMMHMMM"
#define Placeholder2 "YOUSONOFABITCH"
#define A(a) OBJ a "Ammo"
#define O(a) OBJ a
#define P(a) "weapons/" a "/pickup"
#define N(a) .classname = OBJ a, .name = a
#define F(...) .flags = __VA_ARGS__
weaponinfo_t const weaponinfo[weapon_max] = {
   {0, pcl_any, null, "MMMMHMHMMMHMMM"},

#{
   ret = ""
   for wep in weps
      ret += "   {#{wep.slt}, #{wep.pcl}, #{wep.res.join ", "}},\n"
   end
   ret
}
};

// Extern Functions ----------------------------------------------------------|

int Lith_WeaponFromName(struct player *p, int name)
{
   switch(p->pclass)
   {
#{
   ret = ""
   for pcl, wpns in wepn
      wepnames = ["wepnam_fist", "wepnam_chainsaw", "wepnam_pistol", "wepnam_shotgun",
                  "wepnam_supershotgun", "wepnam_chaingun", "wepnam_rocketlauncher",
                  "wepnam_plasmarifle", "wepnam_bfg9000"]
      ret += "   case #{pcl}:\n      switch(name) {\n"
      for wep, i in wpns.each_with_index
         ret += "      case #{wepnames[i]}: return #{wep};\n"
      end
      ret += "      }\n"
   end
   ret
}
   }

   return weapon_unknown;
}
#endif

// EOF
_end_
end

class LithWep
   attr_reader :pcl
   attr_reader :nam
   attr_reader :slt
   attr_reader :res

   def initialize pcl, wf, spl
      @pcl = pcl
      @nam = "weapon_#{spl.shift}"
      @slt = spl.shift
      @res = [
         %<N("#{spl.shift}")>,
         spl.shift,
         "AT_#{spl.shift}",
         *spl
      ]
      @res.push "F(#{wf})" unless wf.empty?
   end
end

def procFile ifp, ofh, ofc
   pcl  = "pcl_any"
   wf   = ""
   weps = []
   wepn = {}

   for ln in ifp
      ln.chomp!
      next if ln.empty?

      pre = ln[0]
      res = ln[1..-1]
      case pre
      when ?:; pcl = "pcl_#{res}"
      when ?%; wf = res
      when ?+; weps.push LithWep.new(pcl, wf, res.split)
      when ?;; wepn[pcl] = res.split.map do |s| "weapon_#{s}" end
      end
   end

   outHeader ofh, weps
   outSource ofc, weps, wepn
end

ifn, ofh, ofc = ARGV[0], ARGV[1], ARGV[2]
procFile open(ifn, "rt"), open(ofh, "wt"), open(ofc, "wt")

## EOF
