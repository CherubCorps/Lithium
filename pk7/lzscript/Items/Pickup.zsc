// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │   By Alison G. Watson. Attribution is encouraged, though not required.   │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

class Lith_ItemGlow : Actor {
   default {
      RenderStyle "Add";
      Alpha 0.7;
      Scale 0.1;
      Translation "Lith_ItemGlow";
      +ForceXyBillboard
      +NoInteraction
      +Bright
   }

   override void beginPlay() {
      super.beginPlay();
   }

   override void tick() {
      if(!isFrozen() && getAge() > 5 && (alpha -= 0.03) < 0) {
         destroy();
      }
   }

   states {
   Spawn:
      LI09 # -1;
      stop;
   }
}

class Lith_WeapGlow : Lith_ItemGlow {
   default {
      Translation "Lith_WeapGlow";
   }

   override void postBeginPlay() {
      super.postBeginPlay();
      if(lith_player_brightweps) {
         A_SetTranslation("Lith_WeapGlowBright");
      }
   }
}

class Lith_UpgrGlow : Lith_ItemGlow {
   default {
      Translation "None";
   }
}

mixin class Lith_Pickup {
   meta int m_pkFlags;
   meta string m_pkSprGf;
   meta string m_pkSprAf;
   meta string m_pkSprCf;
   meta string m_pkSprDf;
   meta string m_pkSprIf;
   meta string m_pkSprMf;
   meta string m_pkSprTf;
   meta string m_pkSprWf;
   Actor m_pkSpr;
   Lith_Sprite m_pkSprG;
   Lith_Sprite m_pkSprA;
   Lith_Sprite m_pkSprC;
   Lith_Sprite m_pkSprD;
   Lith_Sprite m_pkSprI;
   Lith_Sprite m_pkSprM;
   Lith_Sprite m_pkSprT;
   Lith_Sprite m_pkSprW;
   meta class<Actor> m_pkGlow;
   int m_pkGlowFrame;

   property Sprite: m_pkSprGf;
   property SpriteA: m_pkSprAf;
   property SpriteC: m_pkSprCf;
   property SpriteD: m_pkSprDf;
   property SpriteI: m_pkSprIf;
   property SpriteM: m_pkSprMf;
   property SpriteT: m_pkSprTf;
   property SpriteW: m_pkSprWf;
   property Glow: m_pkGlow;
   flagdef Pkup_Generic:  m_pkFlags, 0;
   flagdef Pkup_NoSprite: m_pkFlags, 1;
   flagdef Pkup_NoGlow:   m_pkFlags, 2;

   void pkPostBeginPlay() {
      if(m_pkSprGf) {m_pkSprG.get(m_pkSprGf);}
      if(m_pkSprAf) {m_pkSprA.get(m_pkSprAf);}
      if(m_pkSprCf) {m_pkSprC.get(m_pkSprCf);}
      if(m_pkSprDf) {m_pkSprD.get(m_pkSprDf);}
      if(m_pkSprIf) {m_pkSprI.get(m_pkSprIf);}
      if(m_pkSprMf) {m_pkSprM.get(m_pkSprMf);}
      if(m_pkSprTf) {m_pkSprT.get(m_pkSprTf);}
      if(m_pkSprWf) {m_pkSprW.get(m_pkSprWf);}
      if(!bPkup_NoSprite) {
         m_pkSpr = spawn("Lith_ItemSprite", Pos);
         m_pkSpr.master = self;
      } else {
         m_pkSpr = null;
      }
      m_pkGlowFrame = Lith_UTIL.pData(_pdt_pclass_b);
   }

   void pkTick() {
      if(!m_pkSpr) {
         return;
      }
      if(bPkup_Generic) {
         pkSetSpr(m_pkSprG);
         return;
      }
      if(!players[consolePlayer].camera) {
         return;
      }
      let p = players[consolePlayer].camera;
      /**/ if(m_pkSprAf && p is "Lith_AssassinPlayer")  {pkSetSpr(m_pkSprA);}
      else if(m_pkSprCf && p is "Lith_CyberMagePlayer") {pkSetSpr(m_pkSprC);}
      else if(m_pkSprDf && p is "Lith_DarkLordPlayer")  {pkSetSpr(m_pkSprD);}
      else if(m_pkSprIf && p is "Lith_InformantPlayer") {pkSetSpr(m_pkSprI);}
      else if(m_pkSprMf && p is "Lith_MarinePlayer")    {pkSetSpr(m_pkSprM);}
      else if(m_pkSprTf && p is "Lith_ThothPlayer")     {pkSetSpr(m_pkSprT);}
      else if(m_pkSprWf && p is "Lith_WandererPlayer")  {pkSetSpr(m_pkSprW);}
      else if(m_pkSprGf)                                {pkSetSpr(m_pkSprG);}
   }

   void pkSetSpr(Lith_Sprite s) {
      m_pkSpr.sprite = s.spr;
      m_pkSpr.frame  = s.frm;
   }

   void pkItemGlow() const {
      if(isFrozen() || lith_player_noitemfx || bPkup_NoGlow) {
         return;
      }
      let d = int(distance2D(players[consolePlayer].camera));
      let s = sin(msTimeF() * 0.14285);
      let z = sin(msTimeF() * 0.05714);
      let c = cos(msTimeF() * 0.14285);
      let n = 1 - s;
      switch(d / 512) {
      case 0:
         spawn(m_pkGlow, pos+(s*32,    c*32, 24+z*9) ).frame = m_pkGlowFrame;
         spawn(m_pkGlow, pos+(c*32, n*32-32, 24+s*32)).frame = m_pkGlowFrame;
         spawn(m_pkGlow, pos+(n*32-32, c*32, 24+s*32)).frame = m_pkGlowFrame;
      case 1:
         spawn(m_pkGlow, pos+(   0, s*32, 24+c*32)).frame = m_pkGlowFrame;
         spawn(m_pkGlow, pos+(s*32, c*32, 24+s*32)).frame = m_pkGlowFrame;
      case 2:
         spawn(m_pkGlow, pos+(s*32, 0, 24+c*32)).frame = m_pkGlowFrame;
      default:
         spawn(m_pkGlow, pos+(c*32, s*32, 24+s*32)).frame = m_pkGlowFrame;
      }
   }

   states(Actor) {
   Spawn:
      TNT1 A 1 pkItemGlow();
      loop;
   }
}

/* EOF */
