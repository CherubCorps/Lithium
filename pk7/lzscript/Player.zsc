#include "lzscript/1_Marine/Marine.zsc"
#include "lzscript/2_CyberMage/CyberMage.zsc"
#include "lzscript/3_Informant/Informant.zsc"
#include "lzscript/4_Wanderer/Wanderer.zsc"
#include "lzscript/5_Assassin/Assassin.zsc"
#include "lzscript/6_DarkLord/DarkLord.zsc"
#include "lzscript/7_Thoth/Thoth.zsc"

class Lith_Player : DoomPlayer;

default
{
   Player.SideMove 2, 1;
   Player.ForwardMove 2, 1;
   Player.AirCapacity 0;
   Player.GruntSpeed 16;
   Species "Lith_Player";
   Lith_Player.ViewBob 1;

   +THRUSPECIES;
}

meta double m_vbob;

private double m_rainlerp;

Lith_Cyberspace m_cs;

property ViewBob: m_vbob;

override void BeginPlay()
{
   Super.BeginPlay();
   viewbob = m_vbob;

   GiveInventoryType("Lith_AAGH");
   GiveInventoryType("Lith_IDOL");
}

override void PostBeginPlay()
{
   Super.PostBeginPlay();

// m_cs = Lith_Cyberspace.Create();
}

override void PlayerThink()
{
   if(CallACS("LPData", pdata_semifrozen))
   {
      UserCmd cmd = player.cmd;
      cmd.pitch = cmd.yaw = cmd.roll = 0;
      player.turnticks = 0;
   }

   Super.PlayerThink();
}

private void Lith_RainEffect()
{
   Shader.SetUniform1f(player, "Lith_Rain", "lith_t", level.totaltime / 35.);
   Shader.SetUniform1f(player, "Lith_Rain", "lith_m", m_rainlerp);

   if(player && CallACS("LWData", wdata_dorain) &&
      ceilingpic == skyflatnum && pitch < -5)
   {
      float m = -pitch - 5;
      m_rainlerp = Lith_UTIL.Lerp(m_rainlerp, m / 85., 0.1);
      Shader.SetEnabled(player, "Lith_Rain", true);
   }
   else if(m_rainlerp > 0.01)
      m_rainlerp = Lith_UTIL.Lerp(m_rainlerp, 0, 0.1);
   else
   {
      m_rainlerp = 0;
      Shader.SetEnabled(player, "Lith_Rain", false);
   }
}

private void Lith_ItemVacuum()
{
   if(CallACS("LWData", wdata_fun) & 2)
      for(let it = BlockThingsIterator.Create(self, 70); it.next();)
   {
      if(Inventory(it.thing))
      {
         let mo = Spawn("Lith_Bip", it.thing.pos);
         mo.vel = (frandom(-0.1, 0.1), frandom(-0.1, 0.1), 4);
         mo.A_PlaySound("misc/pop", CHAN_BODY);
         it.thing.destroy();
      }
   }
   else for(let it = BlockThingsIterator.Create(self, 70); it.next();)
   {
      let inv = Lith_BasicPickup(it.thing);

      if(inv && inv.m_vacuum && inv.bSPECIAL && inv.checkSight(self))
      {
         let dst = distance2D(inv);
         let t = clamp((140 - dst) / 1000., 0., 1.);

         if(t)
         {
            let newp = inv.pos * (1 - t) + pos * t;
            inv.tryMove(newp.xy, 20);
         }
      }
   }
}

private void Lith_Crosshair()
{
   // get the actual view angles
   float rp = pitch + CallACS("LPData", pdata_addp)/FIX * 180;
   float ry = angle + CallACS("LPData", pdata_addy)/FIX * 360;

   // trace to where the crosshair should be in world space
   FLineTraceData ltd;
   LineTrace(ry, 2048, rp, 0, player.viewz-pos.z-attackzoffset/2, 0, 0, ltd);

   // create (view-adjusted) normalized lookat vector basis
   vector3 la = pos - ltd.hitlocation;
   la.z = (player.viewz - ltd.hitlocation.z) * level.pixelstretch;
   la /= la.length();

   // get projection angles
   float pp = asin(la.z);
   float py = atan2(la.y, la.x) - 180;

   // first set of rotation to generate the lookat vector
   let q  = Lith_Quaternion.CreateVector(1, 0, 0);
   let qp = Lith_Quaternion.Create(pp, 0, 1, 0);
   let qy = Lith_Quaternion.Create(py, 0, 0, 1);

   q = qp.multiply(q).multiply(qp.makeConjugate());
   q = qy.multiply(q).multiply(qy.makeConjugate());

   // create (pixel stretch-adjusted) normalized pitch vector
   vector2 pvec = (cos(pitch), sin(pitch) * level.pixelstretch);
   pvec /= pvec.length();

   // get the real pitch as according to that vector
   float newpitch = atan2(pvec.y, pvec.x);

   // unproject and normalize
   qy = Lith_Quaternion.Create(-   angle, 0, 0, 1);
   qp = Lith_Quaternion.Create(-newpitch, 0, 1, 0);

   q = qy.multiply(q).multiply(qy.makeConjugate());
   q = qp.multiply(q).multiply(qp.makeConjugate());

   la = q.generateVector();
   la /= la.length();

   int xhx, xhy;
   if(la.x > 0)
   {
      // adjust for FOV
      float fovmod = 1 / tan(player.fov / 2);

      // get NDC position
      float pv = -la.z / la.x * fovmod;
      float ph = -la.y / la.x * fovmod;

      // get screenspace position
      xhx = Lith_UTIL.Round(ph            * 160 + 160);
      xhy = Lith_UTIL.Round(pv * 1.333333 * 120 + 120);
   }
   else
   {
      // not looking at it, just center
      xhx = 160;
      xhy = 120;
   }

   // draw
   uint r = min(CVar.GetCVar('lith_xhair_r', player).getInt(), 255);
   uint g = min(CVar.GetCVar('lith_xhair_g', player).getInt(), 255);
   uint b = min(CVar.GetCVar('lith_xhair_b', player).getInt(), 255);
   uint a = min(CVar.GetCVar('lith_xhair_a', player).getInt(), 255);

   let c = String.Format("#%.2X%.2X%.2X", r, g, b);

   int style = CVar.GetCVar('lith_xhair_style', player).getInt();

   let gb = String.Format("lgfx/XHairs/%ib.png", style);
   let gw = String.Format("lgfx/XHairs/%iw.png", style);

   Lith_URANUS.LHS(self, 320, 240);
   Lith_URANUS.LPS(self, gb, xhx, xhy, 0, 0, a/255.);
   Lith_URANUS.LPS(self, gw, xhx, xhy, 0, 0, a/255., c);
}

override void Tick()
{
   if(CallACS("LPData", pdata_semifrozen))
   {
      // stupid hack to keep the view from moving around
      angle -= 1;
      pitch -= 1;
      A_SetAngle(angle + 1, SPF_INTERPOLATE);
      A_SetPitch(pitch + 1, SPF_INTERPOLATE);
   }

// m_cs.Lith_RotateView(2);

   if(players[consoleplayer].camera == self)
   {
      Lith_URANUS.LEH();
//    m_cs.Lith_DrawFrame();
   }

   Super.Tick();

   Lith_RainEffect();
   Lith_ItemVacuum();

   if(health > 0 && CVar.GetCVar('lith_xhair_enable', player).getBool())
      Lith_Crosshair();
}

override int DamageMobj(Actor inflictor, Actor source, int damage, name mod, int flags = 0, double angle = 0)
{
   if(mod == 'Lith_PlayerMissile')
      return 0;

   CallACS("Lith_RA_Give", Lith_AAGH.Lith_NameToDT(mod));

   let sv = Lith_HERMES.Instance();
   sv.m_dmgtype = mod;
   if(sv.m_dmgworld = !(inflictor || source) || source == self)
      return Super.DamageMobj(inflictor, source, damage, 'None', flags, angle);
   else
      return Super.DamageMobj(inflictor, source, damage, mod, flags, angle);
}

override void Die(Actor source, Actor inflictor, int dmgflags = 0)
{
   target = source;
   Super.Die(null, inflictor, dmgflags);

   let sv = Lith_HERMES.Instance();
   string ob;

   if(source == self) switch(sv.m_dmgtype)
   {
   case 'FatMacRecoil':  ob = "$LITH_OB_S_FatMac";    break;
   case 'Lith_Shrapnel': ob = "$LITH_OB_S_Explosion"; break;
   default:              ob = "(suicide)";            break;
   }
   else if(source)
      ob = sv.m_dmgtype == 'Melee' ? source.hitobituary : source.obituary;
   else switch(sv.m_dmgtype)
   {
   case 'Falling':  ob = "(falling)";  break;
   case 'Crush':    ob = "(crush)";    break;
   case 'Exit':     ob = "(exit)";     break;
   case 'Drowning': ob = "(drowning)"; break;
   case 'Slime':    ob = "(slime)";    break;
   case 'Fire':     ob = "(fire)";     break;
   default:         ob = "(default)";  break;
   }

   sv.m_obituary = StringTable.Localize(ob);

   CallACS("Lith_Obituary");
}

// EOF
