/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson. Attribution is encouraged, though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 */

class Lith_MenuDelegate : MenuDelegateBase {
   private ui ListMenuDescriptor     m_lastDesc;
   private ui ListMenuItemSelectable m_lastSel;
   private ui vector2                m_selPos;

   private ui static vector2 getSelPos(ListMenuItemSelectable sel) {
      return sel ? (sel.getX() - 8.0, sel.getY() + sel.mHeight / 4.0) : (0, 0);
   }

   private ui static ListMenuItemSelectable getSelItem(ListMenuDescriptor desc, int which) {
      return which >= 0 && which < desc.mItems.size() ?
         ListMenuItemSelectable(desc.mItems[which]) :
         null;
   }

   override void playSound(name sndName) {
      if(sndName == 'menu/cursor') {
         return;
      }
      string sndStr = sndName;
      sound  snd    = sndStr;
      S_StartSound(snd, lch_body, CHANF_UI, snd_menuVolume);
   }

   override bool drawSelector(ListMenuDescriptor desc) {
      let num = desc.mSelectedItem;
      let sel = getSelItem(desc, num);

      if(m_lastDesc != desc) {
         m_selPos   = (0, 0);
         m_lastDesc = desc;
      } else if(sel != m_lastSel) {
         S_StartSound("menu/cursor", lch_body, CHANF_UI, snd_menuVolume);
      }
      m_lastSel = sel;

      if(sel) {
         let pos  = getSelPos(sel);
         m_selPos = Lith_UTIL.vec2Lerp(m_selPos, pos, 0.25);
         let dw   = desc.displayWidth();
         let dh   = desc.displayHeight();
         let a    = (sin(gameTic * 10.0) + 1.0) / 2.0;
         let c    = Lith_URANUS.xhairColor();
         let tex  = Lith_URANUS.xhairW();
         if(dw == ListMenuDescriptor.CleanScale) {
            Screen.drawTexture(tex, false, m_selPos.x, m_selPos.y,
                               DTA_Clean,true,
                               DTA_KeepRatio,true,
                               DTA_FillColor,c,
                               DTA_Alpha,a);
         } else {
            Screen.drawTexture(tex, false, m_selPos.x, m_selPos.y,
                               DTA_VirtualWidth,dw,
                               DTA_VirtualHeight,dh,
                               DTA_FillColor,c,
                               DTA_Alpha,a);
         }
      }

      return true;
   }

   override Font pickFont(Font fnt) {
      Font bigupper = "bigupper";
      Font lmidfont = "lmidfont";
      Font ltrmfont = "ltrmfont";
      if(fnt == smallFont) {
         return Lith_URANUS.instance().fntSml();
      } else if(fnt == lmidfont) {
         return Lith_URANUS.instance().fntMid();
      } else if(fnt == ltrmfont) {
         return Lith_URANUS.instance().fntTrm();
      } else if(fnt == bigFont || fnt == bigupper) {
         return Lith_URANUS.instance().fntBig();
      } else {
         return fnt;
      }
   }
}

extend class Lith_URANUS;

private transient ui double m_screenDim;

private ui void tickMenu() {
   if(!(menuDelegate is "Lith_MenuDelegate")) {
      menuDelegate.destroy();
      menuDelegate = new("Lith_MenuDelegate");
   }
}

private ui void drawMenu(RenderEvent evt) {
   if(menuActive && !Menu.getCurrentMenu().dontDim) {
      m_screenDim = Lith_UTIL.lerp(m_screenDim, 0.75, 0.3);
   } else {
      m_screenDim = Lith_UTIL.lerp(m_screenDim, 0.0, 0.1);
   }

   Screen.dim("black", m_screenDim, 0, 0, Screen.getWidth(), Screen.getHeight());
}

/* EOF */
