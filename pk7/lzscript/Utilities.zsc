// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │    By Alison G. Watson & InsanityBringer. Attribution is encouraged,     │
// │                           though not required.                           │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

/* UTIL: Utilities and Tools Intersperse Languages */
struct Lith_UTIL {
   /* fucking degrees system... */
   static double constDeg(double x) {
      x %= 360;
      if(x < 0) x += 360;
      return x;
   }

   static double diffDeg(double a, double b) {
      double d = (b - a) % 360;
      if(d < 0) d += 360;
      return d;
   }

   static double sDiffDeg(double a, double b) {
      double d = b - a;
      if(d ~== 0) return 0;
      d %= 360;
      return 2 * d % 360 - d;
   }

   static double angleLerp(double a, double b, double t) {
      return a + sDiffDeg(a, b) * t;
   }

   static double lerp(double a, double b, double t) {
      return (1 - t) * a + t * b;
   }

   static double easeInOutQuad(double t) {
      if(t < 0.5) {
         return 2.0 * t * t;
      } else {
         double tt = -2.0 * t + 2.0;
         return 1.0 - tt * tt / 2.0;
      }
   }

   static vector2 vec2Lerp(vector2 a, vector2 b, double t) {
      let vec = (lerp(a.x, b.x, t), lerp(a.y, b.y, t));
      return vec;
   }

   static vector3 vec3Lerp(vector3 a, vector3 b, double t) {
      let vec = (lerp(a.x, b.x, t), lerp(a.y, b.y, t), lerp(a.z, b.z, t));
      return vec;
   }

   static color colorLerp(color a, color b, double t) {
      uint rd = uint(lerp(a.r, b.r, t));
      uint gr = uint(lerp(a.g, b.g, t));
      uint bl = uint(lerp(a.b, b.b, t));
      uint al = uint(lerp(a.a, b.a, t));
      return (al << 24) | (rd << 16) | (gr << 8) | bl;
   }

   static int round(double n) {
      return int(n * 1000) % 1000 < 500 ? int(n) : int(n+0.5);
   }

   static vector3 traceFrom(Actor mo, double yaw, double pitch, double dist, double offsetz, bool floor = false, ETraceFlags flags = 0) {
      return Lith_HERMES.instance().traceFromActor(mo, yaw, pitch, dist, offsetZ, floor, flags);
   }

   static vector3 traceFromPos(Sector sec, vector3 pos, double yaw, double pitch, double dist, Actor ignore = null, bool floor = false, ETraceFlags flags = 0) {
      return Lith_HERMES.instance().traceFromPos(sec, pos, yaw, pitch, dist, ignore, floor, flags);
   }

   static play int exec(Actor mo, int scr, int arg0 = 0, int arg1 = 0, int arg2 = 0, int arg3 = 0) {
      return Level.ExecuteSpecial(84, mo, null, false, scr, arg0, arg1, arg2, arg3);
   }

   static int pData(int info, int permutation = 0) {
      return acs_executeWithResult(lsc_pdata, info, permutation);
   }

   static play void stateTick(Actor mo) {
      if(mo.tics >= 0 && --mo.tics <= 0) {
         mo.setState(mo.curState.nextState);
      }
   }

   static bool classExists(string cnam) {
      class<Object> cls = cnam;
      return cls != null;
   }

   static float, float circleSpread(float mdy, float mdp) {
      float dy = fRandom(mdy, 0);
      float dp = fRandom(mdp, 0);
      float a  = fRandom(0, 360);
      return sin(a) * dy, cos(a) * dp;
   }
}

class Lith_LineTracer : LineTracer {
   Actor m_ignore;

   override ETraceStatus traceCallback() {
      let mo = results.hitActor;
      let ln = results.hitLine;
      bool tomare;
      switch(results.hitType) {
      case TRACE_HITACTOR:
         tomare = mo != m_ignore && mo.bShootable && mo.bSolid;
         break;
      case TRACE_HITWALL:
         tomare =
            ln.flags & (Line.ML_BLOCKEVERYTHING |
                        Line.ML_BLOCKHITSCAN |
                        Line.ML_BLOCKING |
                        Line.ML_BLOCKPROJECTILE |
                        Line.ML_BLOCK_PLAYERS) ||
            results.tier != TIER_MIDDLE;
         break;
      default:
         /* get hit, bitch */
         tomare = true;
         break;
      }
      return tomare ? TRACE_STOP : TRACE_SKIP;
   }
}

/* EOF */
