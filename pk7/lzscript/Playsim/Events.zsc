// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │   By Alison G. Watson. Attribution is encouraged, though not required.   │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

extend class Lith_HERMES;

private array<Actor> m_bossBabies;
private int m_bossDeathInit;
private bool m_extraHard;
bool m_tainted;

override void WorldLoaded(WorldEvent ev) {
   if(ev.isSaveGame) {
      if(m_tainted) {
         CallACS("Lith_TimelineInconsistent");
      }
      return;
   }

   m_extraHard = lith_sv_extrahard;
   m_bossLevel = boss_none;
   m_bossBabies.clear();

   if(level.nextMap.left(6) == "enDSeQ") {
      if(level.info.flags & LEVEL_BRUISERSPECIAL || level.info.flags3 & LEVEL3_E1M8SPECIAL) {
         m_bossLevel = boss_barons;
      } else if(level.info.flags3 & LEVEL3_E2M8SPECIAL) {
         m_bossLevel = boss_cyberdemon;
      } else if(level.info.flags3 & LEVEL3_E3M8SPECIAL) {
         m_bossLevel = boss_spiderdemon;
      } else {
         for(let it = ThinkerIterator.create("BossBrain"); it.next();) {
            m_bossLevel = boss_iconofsin;
            if(__lith_fun & lfun_tainted) {
               m_tainted = true;
            }
            break;
         }
      }
   }

   if(!ev.isReOpen) {
      ACS_ExecuteWithResult(lsc_worldopen);
   }

   if(__lith_fun & lfun_ragnarok) Ragnarok();

   if(Lith_UTIL.pData(_pdt_mapf, _mapf_skyreplace)) {
      for(int i = 0, j = level.sectors.size(); i < j; i++) {
         Sector sec = level.sectors[i];
         if(sec.getTexture(Sector.Ceiling) == skyflatnum) {
            if(Lith_UTIL.pData(_pdt_mapc) == _mapc_hell) {
               sec.setColor("#ff7777");
            }
            sec.lightlevel = int(clamp(sec.lightlevel * lith_sv_skydarkening, 64.0, 255.0));
         }
      }
   }
}

static void Ragnarok() {
   S_ChangeMusic("lmusic/Ragnarok.ogg", 0, true, true);

   let sky = TexMan.CheckForTexture("HELP", TexMan.Type_Any);

   level.changeSky(sky, sky);
   level.skyspeed1 = 0.001;
   level.skyspeed2 = 0.001;

   for(int i = 0, j = level.sectors.size(); i < j; i++) {
      Sector sec = level.sectors[i];
      sec.lightlevel = 107;
      sec.flags |= Sector.SECF_ENDGODMODE;
      sec.setAngle(Sector.floor,   frandom(0, 360));
      sec.setAngle(Sector.ceiling, frandom(0, 360));

      for(int k = 0, l = sec.lines.size(); k < l; k++) {
         Line lin = sec.lines[k];
         lin.flags |= Line.ML_DONTDRAW;
         lin.alpha = frandom(0.5, 1);

         for(int m = 0; m < 2; m++) {
            Side sid = lin.sidedef[m];
            if(sid) {
               sid.addTextureXOffset(Side.top,    frandom(-7,7));
               sid.addTextureXOffset(Side.mid,    frandom(-7,7));
               sid.addTextureXOffset(Side.bottom, frandom(-7,7));
               sid.addTextureYOffset(Side.top,    frandom(-7,7));
               sid.addTextureYOffset(Side.mid,    frandom(-7,7));
               sid.addTextureYOffset(Side.bottom, frandom(-7,7));
               sid.light = random(-40, 40);
            }
         }
      }
   }

   Thinker th;
   for(let it = ThinkerIterator.Create("Actor"); (th = it.next());) {
      let mo = Actor(th);
      if(mo && mo.bISMONSTER) PrepareForRagnarok(mo);
   }
}


override void WorldThingDestroyed(WorldEvent ev)
{
   let item = Lith_InventoryItem(ev.thing);
   if(item) item.Lith_Destroy();
}

override void WorldUnloaded(WorldEvent ev) {
   if(!(level.clusterFlags & level.CLUSTER_HUB || level.info.flags2 & LEVEL2_HEXENHACK) || LevelInfo.findLevelInfo(ev.nextMap).cluster != level.cluster) {
      ACS_ExecuteWithResult(lsc_hubclear);
   }
   m_bossDeathInit = 0;

   let it = ThinkerIterator.Create("Lith_InventoryItem");
   for(Lith_InventoryItem mo; mo = Lith_InventoryItem(it.Next());) {
      if(!mo.owner) {
         mo.Lith_Destroy();
      }
   }
}

override void WorldThingSpawned(WorldEvent ev)
{
   let th = ev.Thing;

   if(th is "CommanderKeen") {
      th.bNOBLOOD = true;
      th.SetTag("Commander Keen");
      return;
   }

   if(m_bossLevel == boss_iconofsin && th is "BossBrain")
      m_bossBabies.push(th);

   if(th.bISMONSTER && !(th is "RandomSpawner")) {
      Lith_UTIL.exec(th, lsc_monsterinfo);

      if(__lith_fun & lfun_ragnarok)
         Lith_HERMES.PrepareForRagnarok(th);

      switch(m_bossLevel) {
         case boss_barons:
            if(th.bE1M8Boss) {
               if(th.pos.x == 528) {
                  th.A_SetTranslation('Lith_BlueBaron');
               }
               m_bossBabies.push(th);
            }
            break;
         case boss_cyberdemon:
            if(th.bE2M8Boss || th.bE4M6Boss) {
               m_bossBabies.push(th);
            }
            break;
         case boss_spiderdemon:
            if(th.bE3M8Boss || th.bE4M8Boss) {
               m_bossBabies.push(th);
            }
            break;
      }

      if(m_bossLevel != boss_none) {
         if(m_tainted) {
            th.Health *= 2;
            th.ReactionTime = 0;
            th.DamageMultiply *= 1.5;
         }

         if(th.bBossDeath) {
            th.Health = int(th.Health * 2.7);
            th.ReactionTime = 0;
            th.DamageMultiply *= 1.6;
         }
      }
   }
}

override void WorldTick()
{
   if(m_bossLevel != boss_none) {
      for(int i = 0, m = Level.Lines.Size(); i < m; i++)
         for(int j = 0; j < 3; j++)
            Level.Lines[i].Sidedef[0].SetTextureYOffset(j, Sin(Level.TotalTime)*4);

      if(m_bossDeathInit == 0) {
         bool boss_baby_is_dead;

         if(m_bossBabies.size() == 0) {
            boss_baby_is_dead = false;
         } else {
            boss_baby_is_dead = true;
            for(int i = 0; i < m_bossBabies.size(); i++) {
               if(m_bossLevel == boss_barons) {
                  if(playeringame[consoleplayer] && players[consoleplayer].mo) {
                     SecSpecial spec;
                     players[consoleplayer].mo.floorSector.getSpecial(spec);
                     if(!(spec.flags & Sector.SECF_ENDLEVEL))
                        boss_baby_is_dead = false;
                  }
               } else if(m_bossBabies[i] && m_bossBabies[i].health > 0) {
                  boss_baby_is_dead = false;
               }
            }
         }

         if(boss_baby_is_dead) {
            m_bossDeathInit = level.totaltime;
            if(m_bossLevel == boss_iconofsin && lith_sv_postgame) {
               int nf = __lith_fun;
               if(m_tainted) {
                  nf |=  lfun_division;
                  nf &= ~lfun_tainted;
               } else if(!(nf & lfun_division)) {
                  nf |= lfun_tainted;
               }
               CVar.findCVar('__lith_fun').setInt(nf);
            }
         }
      }
   }
}

override void WorldThingDamaged(WorldEvent ev)
{
   let src = ev.damageSource;
   let dst = ev.thing;

   if(!dst) return;

   let pos = dst.pos + (0, 0, dst.height / 2);

   Lith_RenderProvider.instance().addDamageNum(pos, dst.radius/2, ev.damage, ev.thing);

   if(ev.damageType == 'Bullet' && ev.damage >= 8 && !dst.bNOBLOOD) {
      double vol = clamp(ev.damage / 10.0, 0, 1);
      let mo = Actor.spawn("Lith_Dummy", pos);
      mo.A_StartSound("body/bullethit", lch_body, volume: vol * frandom(0.5, 1.1));
   }

   if(!src || src == dst) return;

   let player = Lith_Player(src);

   if(player) {
      let magnum = Lith_Magnum(player.player.readyWeapon);
      if(magnum) {
         if(dst.health <= 0) {
            magnum.lith_addMarksman();
         } else {
            magnum.lith_addAccurate();
         }
      }
   } else if(src.CountInv("Lith_MonsterID") && (dst.bCOUNTKILL || dst.Player)) {
      src.ACS_ScriptCall("Lith_GiveMonsterEXP", ev.Damage);
   }
}

override void WorldThingDied(WorldEvent ev)
{
   let mo = ev.Thing;
   if(mo.bCOUNTKILL && !mo.bNOBLOOD && mo.Health < mo.GetGibHealth())
      for(int i = 0; i < 20; i++)
   {
      let xo = FRandom(-mo.Radius,mo.Radius);
      let yo = FRandom(-mo.Radius,mo.Radius);
      let zo = FRandom(         0,mo.Height);
      let p = mo.Pos + (xo,yo,zo);
      let bl = Actor.Spawn("Lith_BloodHitCore", p, ALLOW_REPLACE);
      bl.Translation = mo.BloodTranslation;
      if(ev.Inflictor) bl.A_Face(ev.Inflictor);
   }

   int sph = mo.spawnHealth();
   if(mo.bBOSSSPAWNED && sph > 50) {
      Lith_BossBrain to;
      int dmg = sph / 50 * random(1, 4);
      double sc = log10(sph);
      for(let it = ThinkerIterator.create("Lith_BossBrain"); (to = Lith_BossBrain(it.next()));) {
         if(to.m_Shield > 0) {
            let shot = Actor.Spawn("Lith_BossDamage", mo.pos);
            shot.target = mo;
            shot.tracer = to;
            shot.setDamage(dmg);
            shot.scale = (sc, sc);
         }
      }
   }
}

override void worldThingRevived(WorldEvent ev) {
   ev.thing.acs_scriptCall("Lith_ResurrectMonster");
}

override void checkReplacement(ReplaceEvent ev) {
   bool wasFinal = ev.isFinal;
   ev.isFinal = true;
   switch(ev.replacee.GetClassName()) {
   case 'BossBrain': ev.replacement = 'Lith_BossBrain'; return;
   case 'BossEye':   ev.replacement = 'Lith_BossEye';   return;
   case 'SpawnFire': ev.replacement = 'Lith_SpawnFire'; return;
   case 'SpawnShot': ev.replacement = 'Lith_SpawnShot'; return;
   case 'BossTarget': return;
   }
   ev.isFinal = false;
   if(m_extraHard) {
      switch(ev.replacee.GetClassName()) {
      case 'ZombieMan':     ev.replacement = 'Lith_XH_ZombieMan';     return;
      case 'ShotgunGuy':    ev.replacement = 'Lith_XH_ShotgunGuy';    return;
      case 'ChaingunGuy':   ev.replacement = 'Lith_XH_ChaingunGuy';   return;
      case 'DoomImp':       ev.replacement = 'Lith_XH_Imp';           return;
      case 'Demon':         ev.replacement = 'Lith_XH_Demon';         return;
      case 'Spectre':       ev.replacement = 'Lith_XH_Spectre';       return;
      case 'LostSoul':      ev.replacement = 'Lith_XH_LostSoul';      return;
      case 'Fatso':         ev.replacement = 'Lith_XH_Mancubus';      return;
      case 'Arachnotron':   ev.replacement = 'Lith_XH_Arachnotron';   return;
      case 'Cacodemon':     ev.replacement = 'Lith_XH_Cacodemon';     return;
      case 'HellKnight':    ev.replacement = 'Lith_XH_HellKnight';    return;
      case 'BaronOfHell':   ev.replacement = 'Lith_XH_BaronOfHell';   return;
      case 'Revenant':      ev.replacement = 'Lith_XH_Revenant';      return;
      case 'PainElemental': ev.replacement = 'Lith_XH_PainElemental'; return;
      case 'Archvile':      ev.replacement = 'Lith_XH_Archvile';      return;
      case 'Cyberdemon':    ev.replacement = 'Lith_XH_Cyberdemon';    return;
      case 'SpiderMastermind':
         ev.replacement = 'Lith_XH_SpiderMastermind'; return;
      }
   }
   switch(ev.replacee.GetClassName()) {
   case 'MiniZorchRecharge':
   case 'BlasterAmmo':
   case 'GoldWandAmmo':
   case 'MaceAmmo':            ev.replacement = 'Clip';                  break;
   case 'MiniZorchPack':
   case 'BlasterHefty':
   case 'GoldWandHefty':
   case 'MaceHefty':           ev.replacement = 'ClipBox';               break;
   case 'LargeZorchRecharge':
   case 'CrossbowAmmo':        ev.replacement = 'Shell';                 break;
   case 'LargeZorchPack':
   case 'CrossbowHefty':       ev.replacement = 'ShellBox';              break;
   case 'PropulsorZorch':
   case 'PhoenixRodAmmo':      ev.replacement = 'RocketAmmo';            break;
   case 'PropulsorZorchPack':
   case 'ArtiTimeBomb':
   case 'PhoenixRodHefty':     ev.replacement = 'RocketBox';             break;
   case 'PhasingZorch':
   case 'SkullRodAmmo':        ev.replacement = 'Cell';                  break;
   case 'PhasingZorchPack':
   case 'ArtiEgg':
   case 'SkullRodHefty':       ev.replacement = 'CellPack';              break;
   case 'Bootspoon':
   case 'Staff':               ev.replacement = 'Fist';                  break;
   case 'SuperBootspork':
   case 'Gauntlets':           ev.replacement = 'Chainsaw';              break;
   case 'MiniZorcher':
   case 'GoldWand':            ev.replacement = 'Pistol';                break;
   case 'LargeZorcher':
   case 'Crossbow':            ev.replacement = 'Shotgun';               break;
   case 'SuperLargeZorcher':   ev.replacement = 'SuperShotgun';          break;
   case 'RapidZorcher':
   case 'Blaster':             ev.replacement = 'Chaingun';              break;
   case 'ZorchPropulsor':
   case 'PhoenixRod':          ev.replacement = 'RocketLauncher';        break;
   case 'PhasingZorcher':
   case 'Mace':                ev.replacement = 'PlasmaRifle';           break;
   case 'LAZDevice':
   case 'SkullRod':            ev.replacement = 'BFG9000';               break;
   case 'BowlOfVegetables':
   case 'ArtiHealth':          ev.replacement = 'Medikit';               break;
   case 'ArtiInvisibility':    ev.replacement = 'BlurSphere';            break;
   case 'ArtiInvulnerability': ev.replacement = 'InvulnerabilitySphere'; break;
   case 'SuperchargeBreakfast':
   case 'ArtiSuperHealth':     ev.replacement = 'SoulSphere';            break;
   case 'ArtiTomeOfPower':     ev.replacement = 'Berserk';               break;
   case 'UltraGoggles':
   case 'ArtiTorch':           ev.replacement = 'Infrared';              break;
   case 'Zorchpack':
   case 'BagOfHolding':        ev.replacement = 'Backpack';              break;
   case 'BowlOfFruit':
   case 'CrystalVial':         ev.replacement = 'StimPack';              break;
   case 'SuperChexArmor':
   case 'EnchantedShield':     ev.replacement = 'BlueArmor';             break;
   case 'ChexArmor':
   case 'SilverShield':        ev.replacement = 'GreenArmor';            break;
   case 'ComputerAreaMap':
   case 'SuperMap':            ev.replacement = 'AllMap';                break;
   case 'GlassOfWater':        ev.replacement = 'HealthBonus';           break;
   case 'SlimeRepellent':      ev.replacement = 'ArmorBonus';            break;
   case 'SlimeProofSuit':      ev.replacement = 'RadSuit';               break;
   default:                    ev.isFinal     = wasFinal;                break;
   }
}

override void RenderOverlay(RenderEvent evt) {
   double ftic = level.totaltime - m_bossDeathInit + evt.fracTic;
   if(m_bossDeathInit == 0) {
      PpShader.SetEnabled("Lith_End", false);
   } else if(ftic > 15.0) {
      PpShader.SetEnabled("Lith_End", true);
      PpShader.SetUniform1f("Lith_End", "lith_t", ftic - 15.0);
   }
}

override void networkProcess(ConsoleEvent evt) {
   if(evt.name.left(9) == "Lith_Log:") {
      log(evt.args[0], evt.args[1], evt.name.mid(9));
   }
}

/* EOF */
