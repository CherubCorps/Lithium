// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │   By Alison G. Watson. Attribution is encouraged, though not required.   │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

class Lith_RenderProvider;

const canvas_w = 1024;
const canvas_h = 200;

enum DrawType {
   _type_clipSet,
   _type_clipClear,
   _type_setSize,
   _type_line,
   _type_sprite,
   _type_spriteAlpha,
   _type_spriteStencil,
   _type_spriteStencilAlpha,
   _type_text,
   _type_textAlpha,
   _type_rect,
   _type_fill,
}

struct DrawData {
   uint8     type;
   uint8     cr;
   uint8     lnY;
   uint8     style;
   int16     x, y, z, w;
   int16     tsz, tpt;
   float     a;
   Font      fnt;
   color     c;
   textureId tex;
}

struct FadeMsg {
   uint8 fade;
   uint8 time;
   uint8 fSub;
   uint8 alph;
}

const DPTR_MAX = 8192;
const TPTR_MAX = 8192*32;

private DrawData[DPTR_MAX] m_d;
private string  [TPTR_MAX] m_txt;
private int     [TPTR_MAX] m_lnx;
private int                m_tPtr;
private int                m_dPtr;
private FadeMsg[256]       m_fadeMsg;
private vector2            m_virtualSize;
private int                m_breakX;
private bool               m_noDraw;
private bool               m_english;
private Font               m_uFntSml;
private Font               m_lMidFont;
private Font               m_lTrmFont;
private Font               m_lBigFont;
private Font               m_lJTrmFont;
private Font               m_newConsoleFont;
private Lith_LineTracer    m_tracer;

private Canvas m_skyCanvas;
private textureId m_sky, m_skyBase, m_skyB, m_skyC, m_skyLightning;
private int m_skyMode, m_skyFlash, m_skyFlashLen;
private float m_skyFlashPos;
private color m_skyColor, m_skyFlashColor;

private bool m_showItems;
private int  m_itemColor;

private ui textureId m_texBatteryOutline;
private ui textureId m_texBattery;

private int m_lightBattery;

static ui void drawRect(int sx, int sy, int px, int py, color cr) {
   Screen.dim(cr, cr.a/255.0, px, py, sx, sy);
}

clearScope vector2 getScSized(float x, float y, bool kludge = false, vector2 vsz = (0, 0)) {
   if(!vsz.x || !vsz.y) {
      vsz = m_virtualSize;
   }
   float sw = Screen.GetWidth();
   float sh = Screen.GetHeight();

   vector2 xy, sc;

   if(kludge) [sc, xy] = Screen.VirtualToRealCoords((0, 0), ( x,  y), vsz);
   else       [xy, sc] = Screen.VirtualToRealCoords((x, y), (sw, sh), vsz);

   return xy;
}

private void tickNearbyItems() {
   m_showItems = lith_hud_showitems;
   m_itemColor = acs_executeWithResult(lsc_drawcr, lith_hud_itemcolor);
}

private ui void drawNearbyItems(RenderEvent evt) {
   if(!m_showItems) {
      return;
   }
   Font fnt = fntSml();
   for(let it = BlockThingsIterator.create(evt.camera, 256.0); it.next();) {
      let mo = it.thing;
      if(Inventory(mo) && mo.bSpecial) {
         int px, py; bool seen;
         [px, py, seen] = project(mo.pos);
         if(seen) {
            string tag   = mo.getTag();
            float  dist  = mo.distance3D(evt.camera);
            float  alpha = 1.0 - clamp(dist / 256.0, 0.0, 1.0);
            int    sw    = fnt.stringWidth(tag);
            int    cr    = m_itemColor;
            Screen.drawText(fnt, cr, px - sw / 2, py, tag, DTA_Alpha,alpha,
                            DTA_VirtualWidth,320, DTA_VirtualHeight,240);
         }
      }
   }
}

private clearScope int, int ammoAmt(Actor mo, class<Lith_Ammo> ty) const {
   let inv = mo.findInventory(ty);
   int amt = inv.amount;
   int max = inv.maxAmount;
   int clr;
   if(amt == max) {
      clr = CH_L_N;
   } else if(amt > max - max / 4) {
      clr = CH_L_D;
   } else if(amt > max / 2) {
      clr = CH_L_F;
   } else if(amt > max / 4) {
      clr = CH_L_I;
   } else if(amt != 0) {
      clr = CH_L_G;
   } else {
      clr = CH_L_M;
   }
   return amt, clr;
}

private void tickInventory() {
   m_lightBattery = lith_light_battery;
}

private ui void drawInventory(RenderEvent evt) {
   static const string keyClasses[] = {
      "BlueCard",  "RedCard",  "YellowCard",
      "BlueSkull", "RedSkull", "YellowSkull",

      "ChexBlueCard", "ChexRedCard", "ChexYellowCard",

      "KeyBlue", "KeyGreen", "KeyYellow"
   };

   static const string keyText[] = {
      "\cn", "\ca", "\cf",
      "\cn", "\ca", "\cf",

      "\cn", "\ca", "\cf",

      "\cn", "\cd", "\cf"
   };

   if(m_texBatteryOutline.isNull()) {
      m_texBatteryOutline = getTextureForName(":HUD:BatteryOutline");
   }
   if(m_texBattery.isNull()) {
      m_texBattery = getTextureForName(":HUD:Battery");
   }

   let mo = evt.camera;

   string inv_text = "";
   int y = 0;

   int blt, cblt; [blt, cblt] = ammoAmt(mo, 'Lith_BulletAmmo');
   int shl, cshl; [shl, cshl] = ammoAmt(mo, 'Lith_ShellAmmo');
   int rkt, crkt; [rkt, crkt] = ammoAmt(mo, 'Lith_RocketAmmo');
   int nrg, cnrg; [nrg, cnrg] = ammoAmt(mo, 'Lith_PlasmaAmmo');
   int drk, cdrk; [drk, cdrk] = ammoAmt(mo, 'Lith_CannonAmmo');

   inv_text.appendFormat(
      " \c%c%i\c-\n \c%c%i\c-\n \c%c%i\c-\n \c%c%i\c-\n \c%c%i\c-\n",
      cblt, blt,
      cshl, shl,
      crkt, rkt,
      cnrg, nrg,
      cdrk, drk);
   y += 5 * 8;

   bool any_key = false;
   for(int i = 0; i < keyClasses.size(); ++i) {
      class<Key> kt = keyClasses[i];
      if(kt && mo.countInv(kt)) {
         inv_text = inv_text .. keyText[i];
         any_key  = true;
      }
   }
   if(any_key) {
      y += 8;
      inv_text = inv_text .. "\n";
   }

   Screen.drawText(smallFont, Font.CR_WHITE, 0, 0, inv_text,
                   DTA_VirtualWidth,320, DTA_VirtualHeight,240);

   y = drawStatFx(evt, y);

   int battery  = Lith_UTIL.pData(_pdt_flashbattery);
   int bat_life = m_lightBattery * 35;

   if(bat_life > 0 && battery < bat_life) {
      float s = battery / float(bat_life) * 8.0;

      Screen.drawTexture(m_texBatteryOutline, false, 0, y,
                         DTA_VirtualWidth,320, DTA_VirtualHeight,240);

      y += 2;

      vector2 cb, cs;
      cb = getScSized(2, y, vsz: (320, 240));
      cs = getScSized(2, s, vsz: (320, 240));
      Screen.setClipRect(int(cb.x), int(cb.y), int(cs.x), int(cs.y));
      Screen.drawTexture(m_texBattery, false, 2, y,
                         DTA_VirtualWidth,320, DTA_VirtualHeight,240);
      Screen.clearClipRect();

      y += 10;
   }
}

Font fntSml(bool noUnicode = false) const {
   return noUnicode || m_english ? smallFont : m_uFntSml;
}

Font fntMid(bool noUnicode = false) const {
   return noUnicode || m_english ? m_lMidFont : m_uFntSml;
}

Font fntBig(bool noUnicode = false) const {
   return noUnicode || m_english ? m_lBigFont : m_newConsoleFont;
}

Font fntTrm(bool noUnicode = false) const {
   return noUnicode || m_english ? m_lTrmFont : m_lJTrmFont;
}

Font fntAny(name name, bool noUnicode = false) const {
   /**/ if(name == 'smallfnt') return fntSml(noUnicode);
   else if(name == 'lmidfont') return fntMid(noUnicode);
   else if(name == 'ltrmfont') return fntTrm(noUnicode);
   else if(name == 'bigupper') return fntBig(noUnicode);
   else                        return Font.getFont(name);
}

void unload() {
   m_dPtr = 0;
   m_tPtr = 0;
   m_dmgNumInit = false;
   m_skyMode = _msky_nochange;
}

void tick() {
   projectSetRenderer();

   tickNearbyItems();
   tickDmgNums();
   tickScrNums();
   tickCrosshair();
   tickInventory();

   m_dPtr = 0;
   m_tPtr = 0;

   for(int i = 0; i < m_fadeMsg.size(); i++) {
      if(m_fadeMsg[i].fade) {
         if(!m_fadeMsg[i].time) {
            m_fadeMsg[i].fade =
               Max(int(m_fadeMsg[i].fade) - int(m_fadeMsg[i].fSub), 0);
         } else {
            m_fadeMsg[i].time--;
         }
      }
   }

   if(m_skyMode != _msky_nochange && level.skyTexture1 != m_sky) {
      if(m_skyMode == _msky_vanilla) {
         m_skyBase = level.skyTexture1;
      }
      level.changeSky(m_sky, level.skyTexture2);
   }
}

static DrawData getDt(DrawData d) {
   return d;
}

ui void drawSky(RenderEvent evt) {
   let  delta = level.time - m_skyFlash;
   let bdelta = delta >= 0 && delta < m_skyFlashLen;
   let vdelta = bdelta ? 1.0f - (delta + evt.fracTic) / float(m_skyFlashLen) : 0.0f;
   m_skyCanvas.clearScreen("black");
   if(m_skyMode == _msky_shader) {
      color cr = m_skyColor;
      if(bdelta) {
         cr = color(
            255,
            min(int(cr.r * 5.0f * vdelta), 255),
            min(int(cr.g * 5.0f * vdelta), 255),
            min(int(cr.b * 5.0f * vdelta), 255));
      }
      m_skyCanvas.clearScreen(cr);
   } else {
      int skySx, skySy; [skySx, skySy] = TexMan.getSize(m_skyBase);
      skySx *= canvas_h / skySy;
      for(int x = 0, i = 0; x < canvas_w; x += skySx, ++i) {
         m_skyCanvas.drawTexture(m_skyBase, true, x, 0, DTA_DestHeight,canvas_h, DTA_DestWidth,skySx, DTA_FlipY,true);
      }
      /* TODO: draw psx fire additively here */
      if(bdelta) {
         m_skyCanvas.dim("white", vdelta * 0.2f, 0, 0, canvas_w, canvas_h, STYLE_Add);
         m_skyCanvas.drawTexture(m_skyLightning, true, m_skyFlashPos, 0, DTA_Alpha,1.0 - vdelta, DTA_LegacyRenderStyle,STYLE_Add, DTA_Color,m_skyFlashColor, DTA_FlipY,true, DTA_FlipX,int(m_skyFlashPos) & 1 == 0);
      }
   }
}

ui void render(RenderEvent evt) {
   if(m_skyMode != _msky_nochange) {
      drawSky(evt);
   }

   projectSetUp(evt);

   if(evt.camera && !automapActive) {
      bool hud_enabled = false;
      if(evt.camera.player) {
         hud_enabled = Lith_UTIL.pData(_pdt_hudenabled);
      }

      if(hud_enabled) {
         drawNearbyItems(evt);
         drawDmgNums(evt);
         drawCrosshair(evt);
         drawInventory(evt);
      }

      int scw = 320, sch = 240;
      for(int i = 0; i < m_DPtr; i++) {
         let d = getDt(m_d[i]);
         switch(d.Type) {
         case _type_clipSet:
            Screen.setClipRect(d.X, d.Y, d.Z, d.W);
            break;
         case _type_clipClear:
            Screen.clearClipRect();
            break;
         case _type_setSize:
            scw = d.X;
            sch = d.Y;
            break;
         case _type_line:
            Screen.drawLine(d.X, d.Y, d.Z, d.W, d.C);
            break;
         case _type_sprite:
            Screen.drawTexture(d.Tex, false, d.X, d.Y,
                               DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                               DTA_TopOffset,0, DTA_LeftOffset,0,
                               DTA_LegacyRenderStyle,d.Style);
            break;
         case _type_spriteAlpha:
            Screen.drawTexture(d.Tex, false, d.X, d.Y,
                               DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                               DTA_TopOffset,0, DTA_LeftOffset,0,
                               DTA_LegacyRenderStyle,d.Style,
                               DTA_Alpha,d.A);
            break;
         case _type_spriteStencil:
            Screen.drawTexture(d.Tex, false, d.X, d.Y,
                               DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                               DTA_TopOffset,0, DTA_LeftOffset,0,
                               DTA_FillColor,d.C);
            break;
         case _type_spriteStencilAlpha:
            Screen.drawTexture(d.Tex, false, d.X, d.Y,
                               DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                               DTA_TopOffset,0, DTA_LeftOffset,0,
                               DTA_Alpha,d.A, DTA_FillColor,d.C);
            break;
         case _type_text:
            for(int ln = 0; ln < d.tsz; ln++) {
               Screen.drawText(d.Fnt, d.Cr,
                               d.X-m_lnx[d.tpt + ln], d.Y+d.LnY*ln,
                               m_txt[d.tpt + ln],
                               DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                               DTA_LegacyRenderStyle,d.Style);
            }
            break;
         case _type_textAlpha:
            for(int ln = 0; ln < d.tsz; ln++) {
               Screen.drawText(d.Fnt, d.Cr,
                               d.X-m_lnx[d.tpt + ln], d.Y+d.LnY*ln,
                               m_txt[d.tpt + ln],
                               DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                               DTA_Alpha,d.A,
                               DTA_LegacyRenderStyle,d.Style);
            }
            break;
         case _type_rect:
            drawRect(d.Z, d.W, d.X, d.Y, d.C);
            break;
         case _type_fill:
            drawRect(Screen.getWidth(), Screen.getHeight(), 0, 0, d.C);
            break;
         }
      }

      Screen.clearClipRect();

      let p = Lith_Player(evt.camera);
      if(p && p.m_cs) p.m_cs.lith_render();

      if(hud_enabled) {
         drawScrNums(evt);
      }
   }
}

static clearScope textureId getTextureForName(string tex) {
   if(tex.byteAt(0) == CH_COLON) {
      tex.replace(":", "/");
      tex = "lgfx" .. tex .. ".png";
   }
   return TexMan.checkForTexture(tex, TexMan.Type_Any);
}

static Lith_RenderProvider create() {
   let r = new("Lith_RenderProvider");

   r.m_english = Lith_HERMES.localize("LITH_CHECK") == "Eng";

   switch(lith_gui_jpfont) {
   default:
   case font_misaki_gothic: r.m_uFntSml = 'MisakiG';  break;
   case font_misaki_mincho: r.m_uFntSml = 'MisakiM';  break;
   case font_jiskan16:      r.m_uFntSml = 'jiskan16'; break;
   }

   r.m_lMidFont       = 'lmidfont';
   r.m_lTrmFont       = 'ltrmfont';
   r.m_lBigFont       = 'lbigfont';
   r.m_lJTrmFont      = 'ljtrmfont';
   r.m_newConsoleFont = 'newconsolefont';

   r.projectRegister();
   r.m_tracer = new("Lith_LineTracer");

   return r;
}

static clearScope Lith_RenderProvider instance() {
   return Lith_URANUS(StaticEventHandler.find('Lith_URANUS')).m_ren;
}

static int LA(int pos, string s, string fnt) {
   let r = instance();

   int breakx = r.m_breakX ? r.m_breakX - pos : 0x7FFF;

   let fon = r.fntAny(fnt);
   let brl = fon.breakLines(s, breakx);
   int lny = fon.getHeight() * brl.count();
   int lnx = 0;

   for(int i = 0; i < brl.count(); i++) {
      let lnw = brl.stringWidth(i);
      if(lnx < lnw) lnx = lnw;
   }

   return (lnx & 0xFFFF) | ((lny & 0xFFFF) << 16);
}

static int LB(string t) {
   let tx = getTextureForName(t);
   int sx, sy; [sx, sy] = TexMan.GetSize(tx);
   return (sx & 0xFFFF) | ((sy & 0xFFFF) << 16);
}

static void LZ(int w, int h) {
   let r = instance();

   let d = getDt(r.m_d[r.m_DPtr++]);

   d.Type = _type_setSize;

   d.X = w;
   d.Y = h;

   r.m_VirtualSize = (w, h);
}

static void LF(int fnum, int time, int speed, float alpha) {
   let r = instance();

   r.m_fadeMsg[fnum].Time = time;
   r.m_fadeMsg[fnum].FSub = speed;
   r.m_fadeMsg[fnum].Alph = int(alpha * 255.0);
   r.m_fadeMsg[fnum].Fade = 255;
}

static bool LX(int num) {
   let r = instance();
   return r.m_fadeMsg[num].Fade > 0 && r.m_fadeMsg[num].Alph > 0;
}

static int LY(int num) {
   let r = instance();
   return int(r.m_fadeMsg[num].Fade / 255.0 *
              r.m_fadeMsg[num].Alph / 255.0 *
              255.0);
}

static void LL(int x, int y, int z, int w, color c = 0) {
   let r = instance();

   if(r.m_NoDraw) return;
   let d = getDt(r.m_d[r.m_DPtr++]);

   d.Type = _type_line;

   vector2 xy = r.getScSized(x, y);
   vector2 zw = r.getScSized(z, w);
   d.X = int(xy.x);
   d.Y = int(xy.y);
   d.Z = int(zw.x);
   d.W = int(zw.y);

   d.C = c;
}

static void LS(string tex, int xx, int yy, float anum, int flags, color cr = 0) {
   let r = instance();
   if(r.m_NoDraw) return;

   int  x = xx & _xmask;
   int  y = yy & _ymask;
   int xa = xx & _xflag;
   int ya = yy & _yflag;

   let d = getDt(r.m_d[r.m_DPtr]);

   if(flags & _u_fade) {
      d.A  = r.m_fadeMsg[int(anum)].Fade / 255.0;
      d.A *= r.m_fadeMsg[int(anum)].Alph / 255.0;
   } else if(flags & _u_alpha) {
      d.A = anum;
   } else {
      d.A = 1.0;
   }
   if(d.A < 0.001) return;
   ++r.m_dPtr;
   d.Type = d.A != 1.0 ? _type_spriteAlpha : _type_sprite;

   if(flags & _u_add)
      d.Style = STYLE_Add;
   else if(d.Type == _type_spriteAlpha)
      d.Style = STYLE_Translucent;
   else
      d.Style = STYLE_Normal;

   if(flags & _u_color) {
      if(d.Type == _type_spriteAlpha)
         d.Type = _type_spriteStencilAlpha;
      else
         d.Type = _type_spriteStencil;
      d.C = cr;
   }

   d.Tex = getTextureForName(tex);

   int sx, sy; [sx, sy] = TexMan.GetSize(d.Tex);

   switch(xa) {
      default:
      case _xl: d.X = x;          break;
      case _xc: d.X = x - sx / 2; break;
      case _xr: d.X = x - sx;     break;
   }

   switch(ya) {
      default:
      case _yt: d.Y = y;          break;
      case _yc: d.Y = y - sy / 2; break;
      case _yb: d.Y = y - sy;     break;
   }
}

static void LT(string txt, string fnt, int xx, int yy, float anum, int cr, int flags) {
   let r = instance();
   if(r.m_NoDraw) return;

   int  x = xx & _xmask;
   int  y = yy & _ymask;
   int xa = xx & _xflag;
   int ya = yy & _yflag;

   let d = getDt(r.m_d[r.m_DPtr]);

   if(flags & _u_fade) {
      d.A  = r.m_fadeMsg[int(anum)].Fade / 255.0;
      d.A *= r.m_fadeMsg[int(anum)].Alph / 255.0;
   } else if(flags & _u_alpha) {
      d.A = anum;
   } else {
      d.A = 1.0;
   }
   if(d.A < 0.001) return;
   ++r.m_dPtr;
   d.Type = d.A != 1.0 ? _type_textAlpha : _type_text;

   if(flags & _u_add)
      d.Style = STYLE_Add;
   else if(d.Type == _type_textAlpha)
      d.Style = STYLE_Translucent;
   else
      d.Style = STYLE_Normal;

   d.Cr = cr;

   int lnx = 0;

   int breakx = r.m_breakX && xa == _xl ? r.m_breakX - x : 0x7FFF;
   d.Fnt = r.fntAny(fnt, flags & _u_no_unicode);
   d.LnY = d.Fnt.GetHeight();
   let brl = d.Fnt.BreakLines(txt, breakx);

   d.tsz = brl.Count();
   d.tpt = r.m_tPtr;
   r.m_tPtr += d.tsz;

   for(int i = 0; i < d.tsz; i++) {
      r.m_txt[d.tpt + i] = brl.StringAt(i);
      int lnw = brl.stringWidth(i);
      if(lnx < lnw) lnx = lnw;
           if(xa == _x3) r.m_lnx[d.tpt + i] = lnw;
      else if(xa <  _x4) r.m_lnx[d.tpt + i] = 0;
      else               r.m_lnx[d.tpt + i] = lnw / 2;
   }

   switch(xa) {
   default:
   case _x3:
   case _x4:
   case _xl: d.X = x;           break;
   case _x5: d.X = x + lnx / 2; break;
   case _x6:
   case _xc: d.X = x - lnx / 2; break;
   case _xr: d.X = x - lnx;     break;
   }

   switch(ya) {
   default:
   case _yt: d.Y = y;                     break;
   case _yc: d.Y = y - d.LnY * d.tsz / 2; break;
   case _yb: d.Y = y - d.LnY * d.tsz;     break;
   }
}

static void LC(int x = 0, int y = 0, int w = 0, int h = 0, int ww = 0) {
   let r = instance();

   let d = getDt(r.m_d[r.m_DPtr]);

   if(x || y || w || h) {
      /* simple optimization (which also prevents division by zero) */
      if((r.m_NoDraw = w <= 0 || h <= 0)) return;

      d.Type = _type_clipSet;

      vector2 xy = r.getScSized(x, y);
      vector2 zw = r.getScSized(w, h, true);
      d.X = int(xy.x);
      d.Y = int(xy.y);
      d.Z = int(zw.x);
      d.W = int(zw.y);
   } else {
      r.m_NoDraw = false;
      d.Type = _type_clipClear;
   }
   ++r.m_dPtr;

   if(ww) {
      r.m_breakX = x + ww;
   } else {
      r.m_breakX = 0;
   }
}

static void LR(int x = 0, int y = 0, int w = 0, int h = 0, color cr = 0) {
   let r = instance();

   if(r.m_NoDraw) return;
   let d = getDt(r.m_d[r.m_DPtr++]);

   d.Type = _type_rect;

   vector2 xy = r.getScSized(x, y);
   vector2 zw = r.getScSized(w, h, true);
   d.X = int(xy.x);
   d.Y = int(xy.y);
   d.Z = int(zw.x);
   d.W = int(zw.y);

   d.C = cr;
}

static void LW(color cr = 0) {
   let r = instance();

   if(r.m_NoDraw) return;
   let d = getDt(r.m_d[r.m_DPtr++]);

   d.Type = _type_fill;
   d.C = cr;
}

static clearscope void StartSound(Actor mo, sound snd, int slot, int flags, double volume = 1.0, double attenuation = 1.0, double pitch = 1.0) {
   if(slot == lch_ambient) {
      S_StartSound(snd, lch_auto, flags, volume, attenuation, pitch);
   } else if(mo) {
      mo.A_StartSound(snd, slot, flags, volume, attenuation, pitch);
   }
}

clearScope vector3 traceFromPos(Sector sec, vector3 pos, double yaw, double pitch, double dist, Actor ignore, bool floor, ETraceFlags flags) {
   yaw   = Lith_UTIL.constDeg(yaw);
   pitch = Lith_UTIL.constDeg(pitch);

   let len = cos(pitch);
   let dir = (len * cos(yaw), len * sin(yaw), -sin(pitch));

   m_tracer.m_ignore = ignore;
   m_tracer.trace(pos, sec, dir, dist, flags);

   return m_tracer.results.hitPos;
}

clearScope vector3 traceFromActor(Actor mo, double yaw, double pitch, double dist, double offsetZ, bool floor, ETraceFlags flags) {
   return traceFromPos(mo.curSector, mo.pos + (0.0, 0.0, offsetZ), yaw, pitch, dist, mo, floor, flags);
}

void setSkyFlash(int skyFlash, int skyFlashLen) {
   m_skyFlash      = skyFlash;
   m_skyFlashLen   = skyFlashLen / 2;
   m_skyFlashPos   = fRandom(0, canvas_w-200);
   m_skyFlashColor = color(179 + random(0, 76), 220 + random(0, 35), 255, 255);
}

void replaceSky() {
   m_sky.setInvalid();
   m_skyB         = getTextureForName("LITHBSKY");
   m_skyC         = getTextureForName("LITHCSKY");
   m_skyLightning = getTextureForName("LITHSKLI");
   m_skyMode      = Lith_UTIL.pData(_pdt_msky);
   switch(m_skyMode) {
   case _msky_shader:
      color cr;
      /* no atmosphere...? */
      if(Lith_UTIL.pData(_pdt_mflg, _mflg_vacuum)) {
         cr = "black";
      } else {
         switch(Lith_UTIL.pData(_pdt_menv)) {
         case _menv_evil:       cr = "#ff0000"; break;
         case _menv_hell:       cr = "#540203"; break;
         case _menv_interstice: cr = "#160508"; break;
         case _menv_abyss:      cr = "#afafaf"; break;
         default:               cr = "#0c0c0f"; break;
         }
         /* energy in the clouds? */
         if(Lith_UTIL.pData(_pdt_mflg, _mflg_thunder)) {
            cr = color(
               255,
               min(int(cr.r * 1.437f), 255),
               min(int(cr.g * 1.437f), 255),
               min(int(cr.b * 1.437f), 255));
         }
      }
      /* TODO: other env. factors such as humidity */
      m_skyColor = cr;
      m_skyBase  = m_skyC;
      m_sky      = m_skyB;
      break;
   case _msky_replace:
      level.skySpeed1 = 0.0;
      switch(Lith_UTIL.pData(_pdt_menv)) {
      case _menv_evil:
         m_skyBase = getTextureForName("HELP");
         level.skySpeed1 = 0.001;
         break;
      case _menv_hell:
         m_skyBase = getTextureForName("LITHSKRD");
         level.skySpeed1 = 0.01;
         break;
      case _menv_interstice:
         m_skyBase = getTextureForName("LITHSKDE");
         break;
      case _menv_abyss:
         m_skyBase = getTextureForName("LITHWHIT");
         break;
      default:
         m_skyBase = getTextureForName("LITHSKST");
         break;
      }
      m_sky = m_skyC;
      break;
   case _msky_vanilla:
      m_skyBase = level.skyTexture1;
      m_sky     = m_skyC;
      break;
   }
   if(m_sky.isValid()) {
      m_skyCanvas = TexMan.getCanvas("LITHCSKY");
      level.changeSky(m_sky, level.skyTexture2);
   }
}

/* EOF */
