/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson. Attribution is encouraged, though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 */

class Lith_DamageNum {
   vector3        m_origin;
   int            m_damage;
   int            m_ticks;
   int            m_origTick;
   Lith_DamageNum m_next;
}

extend class Lith_Player;

private bool m_dmgNumInit;
private int m_dmgNumAmount;
private Lith_DamageNum[_dnum_max] m_dmgNum;

void Lith_AddDamageNum(vector3 origin, double w, int damage) {
   if(CVar.getCVar('lith_hud_showdamage', player).getBool()) {
      if(!m_dmgNumInit) {
         for(int i = 0; i < _dnum_max; i++) {
            m_dmgNum[i] = new("Lith_DamageNum");
         }
         m_dmgNumInit = true;
         m_dmgNumAmount = 0;
      }

      if(m_dmgNumAmount >= 1500) {
         return;
      }

      m_dmgNumAmount++;

      Lith_DamageNum start;

      if(damage >= 120) {
         start = m_dmgNum[_dnum_crit];
      } else if(level.vec3Diff(pos, origin).length() > 1024) {
         start = m_dmgNum[_dnum_smol];
      } else {
         start = m_dmgNum[_dnum_norm];
      }

      let dnum = new("Lith_DamageNum");

      dnum.m_origin   = origin + (frandom(-w,w), frandom(-w,w), frandom(-9,9));
      dnum.m_damage   = damage;
      dnum.m_ticks    = 35 + min(damage, 120) / 3;
      dnum.m_origTick = level.totalTime;
      dnum.m_next     = start.m_next;

      start.m_next = dnum;
   }
}

private void Lith_ShowDamageNums(int which) {
   Lith_DamageNum start = m_dmgNum[which];

   if(!start) return;

   Lith_DamageNum dnum = start.m_next, prev = null;

   while(dnum) {
      if(!dnum.m_ticks) {
         let next = dnum.m_next;
         if(prev) prev.m_next = next;
         dnum.destroy();
         dnum = next;
         m_dmgNumAmount--;
      } else {
         int a = int((dnum.m_ticks < 15 ? dnum.m_ticks / 15.0 : 1.0) * 255);
         int x, y; bool seen; [x, y, seen] = Lith_Unproject(dnum.m_origin);

         if(seen) {
            ACS_ExecuteWithResult(lsc_drawdmgnum,
                                  which | a << 2, dnum.m_damage, x, y);
         }

         int speed = dnum.m_ticks / 5;

         if(speed != 0) {
            if(speed < 4) {
               dnum.m_origin.z += 0.5;
            } else if(speed < 6) {
               dnum.m_origin.z += 1.0;
            } else {
               dnum.m_origin.z += 1.5;
            }
         }

         dnum.m_ticks--;

         prev = dnum;
         dnum = dnum.m_next;
      }
   }
}

private void Lith_PlayerIndicator(PlayerInfo p) {
   let mo = p.MO;

   int x, y; bool seen; [x, y, seen] = Lith_Unproject(mo.pos + (0, 0, mo.height));
   if(seen) ACS_ExecuteWithResult(lsc_drawplayericon, mo.PlayerNumber(), x, y);
}

/* EOF */
