#!/usr/bin/env ruby
## Copyright © 2017 Graham Sanderson, all rights reserved.
## CompileFS: Formatted text → LANGUAGE processor.

def escape text
   text.gsub(/((?<m>\\)(?!c))|(?<m>")/, "\\\\\\k<m>").gsub(/\n/, "\\n")
end

def split_arg text, sp
   text.split(sp, 2).map {|s| s.strip}
end

def single_line txt, set
   "\"#{txt}\" = \"#{escape set}\";\n"
end

def comment arg
   "\n//#{arg}\n"
end

def buf_lines type, buf
   buf.pop if buf.last.chomp.empty?
   case type
   when :just
      buf.each.with_index.inject("") do |sum, (s, i)|
         if i < buf.size-1 then sum + "   \"#{escape s.chomp}\\n\"\n"
         else                   sum + "   \"#{escape s.chomp}\";\n" end
      end
   when :conc
      buf = [*buf, "\n"].each_cons(2).map do |s, n|
            if s == "\n" then "\n\n"
         elsif n == "\n" then s.chomp
         else                 s.chomp + " " end
      end

      buf.each.with_index.inject("") do |sum, (s, i)|
         if i < buf.size-1 then sum + "   \"#{escape s}\"\n"
         else                   sum + "   \"#{escape s.chomp}\";\n" end
      end
   end
end

def parse_file lns
   wr  = nil
   buf = nil
   out = ""
   for ln in lns
      type, arg = ln[0..1], ln.chomp[2..-1]
      case type
      when "##"
         if wr then out << buf_lines(wr, buf); wr = nil end
         out << comment(arg)
      when "=="
         if wr then out << buf_lines(wr, buf); wr = nil end
         txt, set = split_arg arg, "|"
         out << single_line(txt, set)
      when "%%"
         if wr then out << buf_lines(wr, buf) end
         wr, buf = :just, []
         out << "\"#{arg.strip}\" =\n"
      when "@@"
         if wr then out << buf_lines(wr, buf) end
         wr, buf = :conc, []
         out << "\"#{arg.strip}\" =\n"
      when "++"
         if wr then out << buf_lines(wr, buf); wr = nil end
         txt, set = split_arg arg, "|"
         out << "\"#{txt}\" =\n"
         out << comment(" #{set}")
         out << buf_lines(:just, open(set, "rt").read.chomp.lines)
      else
         if wr then buf << ln end
      end
   end
   if wr then out << buf_lines(wr, buf) end
   out
end

def proc_file lns, nam
   txt = "// This file was generated by compilefs.\n" +
         "// Edit only if you aren't going to recompile.\n" +
         "[enu default]\n\n"

   for ln in lns
      type, arg = split_arg ln, ":"
      if arg
         case type
         when "comment"
            txt << comment(" #{arg}")
         when "put data"
            set, out = split_arg arg, "->"
            txt << single_line(out, set)
         when "put file"
            fnam, out = split_arg arg, "->"
            txt << "\"#{out}\" =\n"
            txt << comment(" #{fnam}")
            txt << buf_lines(:just, open(fnam, "rt").read.chomp.lines)
         when "parse file"
            txt << parse_file(open(arg, "rt").read.chomp.lines)
         end
      end
   end

   IO.write nam, txt
end

def run_file lns
   lns = lns.each
   dir = "."
   ths = []

   loop do
      ln = lns.next

      type, arg = split_arg ln, " "
      if arg and type == "in"
         type, arg = split_arg arg, " "
         case type
         when "directory"
            dir = arg
         when "file"
            txt = []

            while lns.peek.strip != "done"
               txt << lns.next
            end
            lns.next

            ths << Thread.start("#{dir}/#{arg}", txt) do |nam, txt|
               proc_file txt, nam
            end
         end
      end
   end

   ths.each {|th| th.join}
end

def join_all th
   if th then th.each{|t| p t; join_all t.value} end
end

def main
   for arg in ARGV
      run_file(open(arg, "rt").read.chomp.lines)
   end
end

main

## EOF
