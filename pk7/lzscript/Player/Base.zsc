/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson & InsanityBringer. Attribution is encouraged,
 * though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 */

class Lith_Player : DoomPlayer;

default {
   Player.SideMove 2, 1;
   Player.ForwardMove 2, 1;
   Player.AirCapacity 0;
   Player.GruntSpeed 16;
   Species "Lith_Player";
   Lith_Player.ViewBob 1;

   +THRUSPECIES
}

meta double m_VBob;

private double m_RainLerp;

Lith_Flashlight m_light;

Lith_Cyberspace m_cs;

bool m_grabInput;
bool m_onGround;
bool m_wasFrozen;

int m_DmgFac;

double m_VPitch, m_LastVPitch;
double m_IPitch, m_LastIPitch;

double m_VYaw, m_LastVYaw;
double m_IYaw, m_LastIYaw;

double m_ZVel, m_LastZVel;

double m_VXVel, m_LastVXVel;
double m_VYVel, m_LastVYVel;
double m_VZVel, m_LastVZVel;

Lith_MapMarker    m_curMark;
Lith_AdviceMarker m_curAdvice;

int m_wasDamaged;

property ViewBob: m_VBob;

override void BeginPlay() {
   Super.BeginPlay();
   viewbob = m_VBob;
   m_wasFrozen = false;
}

override void GiveDefaultInventory() {
   GiveInventoryType("Lith_IDOL");
}

void Lith_GiveDefItem(class<Inventory> type, int amount) {
   let item = Inventory(Spawn(type));
   item.bIGNORESKILL = true;
   item.Amount = amount;
   item.CallTryPickup(self);
}

void Lith_GiveDefWeapon(class<Weapon> type) {
   let wep = Weapon(Spawn(type));
   wep.bIGNORESKILL = true;
   wep.Amount = 1;
   wep.CallTryPickup(self);
   Player.ReadyWeapon = Player.PendingWeapon = wep;
}

override void PlayerThink() {
   if(level.levelnum == 1911777) return;

   if(Lith_UTIL.pData(self, pdata_semifrozen)) {
      UserCmd cmd = player.cmd;
      cmd.pitch = cmd.yaw = cmd.roll = 0;
      player.turnticks = 0;
   }

   m_onGround = pos.z - floorz <= 16 || bONMOBJ || bMBFBOUNCER || player.cheats & CF_NOCLIP2;

   Super.PlayerThink();
}

private void Lith_RainEffect() {
   Shader.SetUniform1f(player, "Lith_Rain", "lith_t", level.totaltime / 15.);
   Shader.SetUniform1f(player, "Lith_Rain", "lith_m", m_RainLerp);

   if(player && ACS_ExecuteWithResult(lsc_wdata, wdata_dorain) &&
      ceilingpic == skyflatnum && pitch < -5) {
      double m = -pitch - 5;
      m_RainLerp = Lith_UTIL.Lerp(m_RainLerp, m / 85., 0.1);
      Shader.SetEnabled(player, "Lith_Rain", true);
   } else if(m_RainLerp > 0.01) {
      m_RainLerp = Lith_UTIL.Lerp(m_RainLerp, 0, 0.1);
   } else {
      m_RainLerp = 0;
      Shader.SetEnabled(player, "Lith_Rain", false);
   }
}

private void Lith_ItemVacuum() {
   if(__lith_fun & lfun_bips) {
      for(let it = BlockThingsIterator.Create(self, 70); it.next();) {
         if(Inventory(it.thing)) {
            let mo = Spawn("Lith_Bip", it.thing.pos);
            mo.vel = (frandom(-0.1, 0.1), frandom(-0.1, 0.1), 4);
            mo.A_StartSound("misc/pop", lch_body);
            it.thing.destroy();
         }
      }
   } else {
      for(let it = BlockThingsIterator.Create(self, 70); it.next();) {
         let inv = Lith_BasicPickup(it.thing);

         if(inv && inv.bVACUUM && inv.bSPECIAL && inv.checkSight(self)) {
            let dst = distance2D(inv);
            let t = clamp((140 - dst) / 1000., 0., 1.);

            if(t) {
               let newp = inv.pos * (1 - t) + pos * t;
               inv.tryMove(newp.xy, 20);
            }
         }
      }
   }
}

void Lith_PreTick() {
   if(m_wasDamaged) {
      --m_wasDamaged;
   } else if(Lith_UTIL.pData(self, pdata_pclass) & (pcl_wanderer | pcl_thoth) &&
             health < Lith_UTIL.pData(self, pdata_oldhealth)) {
      m_wasDamaged = 7;
   }

   if(!m_wasFrozen && isFrozen()) {
      if(player.psprites) player.psprites.tics = -1;
      viewBob = 0;
   } else if(m_wasFrozen && !isFrozen()) {
      if(player.psprites) player.psprites.tics = player.psprites.curState.tics;
      viewBob = m_VBob;
   }
   m_wasFrozen = isFrozen();

   /* stupid hack to keep the view from moving around */
   if(Lith_UTIL.pData(self, pdata_semifrozen)) {
      angle -= 1;
      pitch -= 1;
      A_SetAngle(angle + 1, SPF_INTERPOLATE);
      A_SetPitch(pitch + 1, SPF_INTERPOLATE);
   }

   /* draw stuff if we're the camera */
   if(m_cs) m_cs.lith_drawFrame();
   Lith_URANUS.LE();
}

void Lith_PostTick() {
   if(lith_player_rainshader)
      Lith_RainEffect();
   else
      Shader.SetEnabled(player, "Lith_Rain", false);

   Lith_ItemVacuum();

   Lith_URANUS.LZ(320, 240);

   Lith_ShowMapMarker();
   Lith_ShowAdviceMarker();
   Lith_BobWeapon();
}

override void Tick()
{
   if(level.levelnum == 1911777) return;

   if(player && player.mo == self) Lith_PreTick();

   Super.Tick();

   if(player && player.mo == self) Lith_PostTick();
}

override void CheckPitch() {
   if(!Level.IsFreelookAllowed()) {
      Pitch = 0;
   } else {
      int clook = Player.Cmd.Pitch;

      if(clook != 0) {
         if(clook == int16.min) {
            Player.Centering = true;
         } else if(!Player.Centering) {
            Pitch = Clamp(Pitch - clook * (360 / FIX), Player.MinPitch, Player.MaxPitch);
         }
      }
   }

   if(Player.Centering) {
      if(Abs(Pitch) > 2) {
         A_SetPitch(Pitch * (3 / 4.0), SPF_INTERPOLATE);
      } else {
         Pitch = 0;
         Player.Centering = false;
         if(PlayerNumber() == ConsolePlayer)
            LocalViewPitch = 0;
      }
   }
}

override void CheckAirSupply() {
   /* No. */
}

/* EOF */
