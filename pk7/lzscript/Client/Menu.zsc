// ╭──────────────────────────────────────────────────────────────────────────╮
// │                                                                          │
// │             Distributed under the CC0 public domain license.             │
// │   By Alison G. Watson. Attribution is encouraged, though not required.   │
// │                See licenses/cc0.txt for more information.                │
// │                                                                          │
// ╰──────────────────────────────────────────────────────────────────────────╯

class Lith_MenuDelegate : MenuDelegateBase {
   private ui ListMenuDescriptor     m_lastDesc;
   private ui ListMenuItemSelectable m_lastSel;
   private ui vector2                m_selPos;

   private ui static vector2 getSelPos(ListMenuItemSelectable sel) {
      return sel ? (sel.getX() - 8.0, sel.getY() + sel.mHeight / 4.0) : (0, 0);
   }

   private ui static ListMenuItemSelectable getSelItem(ListMenuDescriptor desc, int which) {
      return which >= 0 && which < desc.mItems.size() ?
         ListMenuItemSelectable(desc.mItems[which]) :
         null;
   }

   static ui Lith_MenuDelegate create() {
      let m = new("Lith_MenuDelegate");
      return m;
   }

   override void playSound(name sndName) {
      if(sndName == 'menu/cursor') {
         return;
      }
      string sndStr = sndName;
      sound  snd    = sndStr;
      S_StartSound(snd, lch_body, CHANF_UI, snd_menuVolume);
   }

   override bool drawSelector(ListMenuDescriptor desc) {
      let num = desc.mSelectedItem;
      let sel = getSelItem(desc, num);

      if(m_lastDesc != desc) {
         m_selPos   = (0, 0);
         m_lastDesc = desc;
      } else if(sel != m_lastSel) {
         S_StartSound("menu/cursor", lch_body, CHANF_UI, snd_menuVolume);
      }
      m_lastSel = sel;

      if(sel) {
         let pos  = getSelPos(sel);
         m_selPos = Lith_UTIL.vec2Lerp(m_selPos, pos, 0.25);
         let dw   = desc.displayWidth();
         let dh   = desc.displayHeight();
         let a    = (sin(gameTic * 10.0) + 1.0) / 2.0;
         let r    = Lith_RenderProvider.instance();
         let c    = r.xhairColor();
         let tex  = r.xhairW();
         if(dw == ListMenuDescriptor.CleanScale) {
            Screen.drawTexture(tex, false, m_selPos.x, m_selPos.y,
                               DTA_Clean,true,
                               DTA_KeepRatio,true,
                               DTA_FillColor,c,
                               DTA_Alpha,a);
         } else {
            Screen.drawTexture(tex, false, m_selPos.x, m_selPos.y,
                               DTA_VirtualWidth,dw,
                               DTA_VirtualHeight,dh,
                               DTA_FullScreenScale,FSMODE_SCALETOFIT43,
                               DTA_FillColor,c,
                               DTA_Alpha,a);
         }
      }

      return true;
   }

   override Font pickFont(Font fnt) {
      Font bigupper = "bigupper";
      Font lmidfont = "lmidfont";
      Font ltrmfont = "ltrmfont";
      if(fnt == smallFont) {
         return Lith_RenderProvider.instance().fntSml();
      } else if(fnt == lmidfont) {
         return Lith_RenderProvider.instance().fntMid();
      } else if(fnt == ltrmfont) {
         return Lith_RenderProvider.instance().fntTrm();
      } else if(fnt == bigFont || fnt == bigupper) {
         return Lith_RenderProvider.instance().fntBig();
      } else {
         return fnt;
      }
   }
}

class ListMenuItemLith_CreditsMenuScroll : ListMenuItemTextItem {
   bool m_right;

   void init(ListMenuDescriptor desc, string text, string hotKey, bool right) {
      super.init(desc, text, hotkey, 'None');
      m_right = right;
   }

   override bool activate() {
      let mn = Lith_CreditsMenu(Menu.getCurrentMenu());
      if(mn) mn.changeSection(m_right);
      return true;
   }
}

class ListMenuItemLith_VersionName : ListMenuItem {
   void init(ListMenuDescriptor desc, double x, double y) {
      super.init(x, y);
   }

   override void draw(bool selected, ListMenuDescriptor desc) {
      drawText(desc, desc.mFont, Font.CR_WHITE, mXPos, mYPos, LITH_VERSION, false);
   }
}

class Lith_CreditsMenu : ListMenu {
   array<BrokenLines> m_sections;
   int                m_sectionTic;
   int                m_curSection;
   Font               m_font;

   static void addSection(string txt) {
      let mn = Lith_CreditsMenu(Menu.getCurrentMenu());
      if(mn) {
         mn.m_sections.push(mn.m_font.breakLines(txt, 640));
      }
   }

   void changeSection(bool right) {
      if(right) ++m_curSection;
      else      --m_curSection;
      if(m_curSection < 0) {
         m_curSection = m_sections.size() - 1;
      } else if(m_curSection >= m_sections.size()) {
         m_curSection = 0;
      }
      m_sectionTic = gameTic;
   }

   override void drawer() {
      super.drawer();

      if(!m_sections.size()) {
         m_font = "ltrmfont";
         callAcs("Lith_OpenCreditsMenu");
         m_sectionTic = gameTic;
         m_curSection = 0;
      }

      int tic = gameTic - m_sectionTic;
      float xx =
         640.0 *
         (1.0 - Lith_UTIL.easeInOutQuad(clamp(tic / 35.0, 0.0, 1.0)));

      int lny = m_font.getHeight();
      let sec = m_sections[m_curSection];
      for(uint lnN = 0, lnC = sec.count(); lnN < lnC; ++lnN) {
         let   ln = sec.stringAt(lnN);
         float x  = 320.0 - m_font.stringWidth(ln) / 2.0 + xx;
         float y  = 240.0 - lny * lnC / 2.0 + lny * lnN;
         x += cos(y + gameTic * 2.0) * 8.0;
         y += sin(y + gameTic * 2.0) * 8.0 * 1.33333;
         Screen.drawText(m_font, Font.CR_UNTRANSLATED, x, y, ln,
                         DTA_VIRTUALWIDTH, 640, DTA_VIRTUALHEIGHT, 480);
      }
   }
}

class Lith_SkillEpMenu : ListMenu {
   override void init(Menu parent, ListMenuDescriptor desc) {
      super.init(parent, desc);
      for(int i = 0, s = mDesc.mItems.size(); i < s; ++i) {
         mDesc.mItems[i].setX(160 - mDesc.mItems[i].getWidth() / 2);
      }
   }
}

extend class Lith_RenderProvider;

private transient ui int              m_screenDim;
private transient ui Shape2DTransform m_menuRectXf;
private transient ui Shape2D          m_menuRect;

ui void tickMenu() {
   if(!m_menuRectXf) {
      m_menuRectXf = new("Shape2DTransform");
      m_menuRect   = new("Shape2D");
   }

   if(menuActive && !Menu.getCurrentMenu().dontDim) {
      if(m_screenDim < 15) ++m_screenDim;
   } else {
      if(m_screenDim > 0) --m_screenDim;
   }

   if(m_screenDim) {
      double dim  = m_screenDim / 15.0;
      double dimx = Lith_UTIL.easeInOutQuad(dim) / 2.0;
      double dimy = dim / 2.0;
      m_menuRect.clear();
      m_menuRect.pushVertex((0, 0));
      m_menuRect.pushVertex((0.5 + dimx, 0.5 - dimy));
      m_menuRect.pushVertex((0.5 - dimx, 0.5 + dimy));
      m_menuRect.pushVertex((1, 1));
      m_menuRect.pushCoord((0, 0));
      m_menuRect.pushCoord((1, 0));
      m_menuRect.pushCoord((0, 1));
      m_menuRect.pushCoord((1, 1));
      m_menuRect.pushTriangle(0, 3, 1);
      m_menuRect.pushTriangle(0, 2, 3);
   }
}

ui void drawMenu(RenderEvent evt) {
   if(m_screenDim) {
      int size = Screen.getHeight() / 14;
      int w = Screen.getWidth()  / size;
      int h = Screen.getHeight() / size;
      for(int y = 0; y <= h; ++y) {
         for(int x = 0; x <= w; ++x) {
            m_menuRectXf.clear();
            m_menuRectXf.scale((size, size));
            m_menuRectXf.translate((x * size, y * size));
            m_menuRect.setTransform(m_menuRectXf);
            Screen.DrawShape(skyflatnum, false, m_menuRect, DTA_Alpha,0.5, DTA_FillColor,0);
         }
      }
   }
}

/* EOF */
