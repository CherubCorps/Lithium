/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson. Attribution is encouraged, though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 */

class Lith_MenuDelegate : MenuDelegateBase {
   private ui ListMenuDescriptor     m_lastDesc;
   private ui ListMenuItemSelectable m_lastSel;
   private ui vector2                m_selPos;

   private ui static vector2 getSelPos(ListMenuItemSelectable sel) {
      return sel ? (sel.getX() - 8.0, sel.getY() + sel.mHeight / 4.0) : (0, 0);
   }

   private ui static ListMenuItemSelectable getSelItem(ListMenuDescriptor desc, int which) {
      return which >= 0 && which < desc.mItems.size() ?
         ListMenuItemSelectable(desc.mItems[which]) :
         null;
   }

   override void playSound(name sndName) {
      if(sndName == 'menu/cursor') {
         return;
      }
      string sndStr = sndName;
      sound  snd    = sndStr;
      S_StartSound(snd, lch_body, CHANF_UI, snd_menuVolume);
   }

   override bool drawSelector(ListMenuDescriptor desc) {
      let num = desc.mSelectedItem;
      let sel = getSelItem(desc, num);

      if(m_lastDesc != desc) {
         m_selPos   = (0, 0);
         m_lastDesc = desc;
      } else if(sel != m_lastSel) {
         S_StartSound("menu/cursor", lch_body, CHANF_UI, snd_menuVolume);
      }
      m_lastSel = sel;

      if(sel) {
         let pos  = getSelPos(sel);
         m_selPos = Lith_UTIL.vec2Lerp(m_selPos, pos, 0.25);
         let dw   = desc.displayWidth();
         let dh   = desc.displayHeight();
         let a    = (sin(gameTic * 10.0) + 1.0) / 2.0;
         let c    = Lith_URANUS.xhairColor();
         let tex  = Lith_URANUS.xhairW();
         if(dw == ListMenuDescriptor.CleanScale) {
            Screen.drawTexture(tex, false, m_selPos.x, m_selPos.y,
                               DTA_Clean,true,
                               DTA_KeepRatio,true,
                               DTA_FillColor,c,
                               DTA_Alpha,a);
         } else {
            Screen.drawTexture(tex, false, m_selPos.x, m_selPos.y,
                               DTA_VirtualWidth,dw,
                               DTA_VirtualHeight,dh,
                               DTA_FillColor,c,
                               DTA_Alpha,a);
         }
      }

      return true;
   }

   override Font pickFont(Font fnt) {
      Font bigupper = "bigupper";
      Font lmidfont = "lmidfont";
      Font ltrmfont = "ltrmfont";
      if(fnt == smallFont) {
         return Lith_URANUS.instance().fntSml();
      } else if(fnt == lmidfont) {
         return Lith_URANUS.instance().fntMid();
      } else if(fnt == ltrmfont) {
         return Lith_URANUS.instance().fntTrm();
      } else if(fnt == bigFont || fnt == bigupper) {
         return Lith_URANUS.instance().fntBig();
      } else {
         return fnt;
      }
   }
}

class ListMenuItemLith_CreditsMenuScroll : ListMenuItemTextItem {
   bool m_right;

   void init(ListMenuDescriptor desc, string text, string hotKey, bool right) {
      super.init(desc, text, hotkey, 'None');
      m_right = right;
   }

   override bool activate() {
      let mn = Lith_CreditsMenu(Menu.getCurrentMenu());
      if(mn) mn.changeSection(m_right);
      return true;
   }
}

class Lith_CreditsMenu : ListMenu {
   array<BrokenLines> m_sections;
   int                m_sectionTic;
   int                m_curSection;
   Font               m_font;

   static void addSection(string txt) {
      let mn = Lith_CreditsMenu(Menu.getCurrentMenu());
      if(mn) {
         mn.m_sections.push(mn.m_font.breakLines(txt, 640));
      }
   }

   void changeSection(bool right) {
      if(right) ++m_curSection;
      else      --m_curSection;
      if(m_curSection < 0) {
         m_curSection = m_sections.size() - 1;
      } else if(m_curSection >= m_sections.size()) {
         m_curSection = 0;
      }
      m_sectionTic = gameTic;
   }

   override void drawer() {
      super.drawer();

      if(!m_sections.size()) {
         m_font = "ltrmfont";
         callAcs("Lith_OpenCreditsMenu");
         m_sectionTic = gameTic;
         m_curSection = 0;
      }

      int tic = gameTic - m_sectionTic;
      float xx =
         640.0 *
         (1.0 - Lith_UTIL.easeInOutQuad(clamp(tic / 35.0, 0.0, 1.0)));

      int lny = m_font.getHeight();
      let sec = m_sections[m_curSection];
      for(uint lnN = 0, lnC = sec.count(); lnN < lnC; ++lnN) {
         let   ln = sec.stringAt(lnN);
         float x  = 320.0 - m_font.stringWidth(ln) / 2.0 + xx;
         float y  = 240.0 - lny * lnC / 2.0 + lny * lnN;
         x += cos(y + gameTic * 2.0) * 8.0;
         y += sin(y + gameTic * 2.0) * 8.0 * 1.33333;
         Screen.drawText(m_font, Font.CR_UNTRANSLATED, x, y, ln,
                         DTA_VIRTUALWIDTH, 640, DTA_VIRTUALHEIGHT, 480);
      }
   }
}

extend class Lith_URANUS;

private transient ui double m_screenDim;

private ui void tickMenu() {
   if(!(menuDelegate is "Lith_MenuDelegate")) {
      menuDelegate.destroy();
      menuDelegate = new("Lith_MenuDelegate");
   }
}

private ui void drawMenu(RenderEvent evt) {
   if(menuActive && !Menu.getCurrentMenu().dontDim) {
      m_screenDim = Lith_UTIL.lerp(m_screenDim, 0.75, 0.3);
   } else {
      m_screenDim = Lith_UTIL.lerp(m_screenDim, 0.0, 0.1);
   }

   Screen.dim("black", m_screenDim, 0, 0, Screen.getWidth(), Screen.getHeight());
}

/* EOF */
