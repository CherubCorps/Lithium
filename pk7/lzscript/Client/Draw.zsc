/* ---------------------------------------------------------------------------|
 *
 * Distributed under the CC0 public domain license.
 * By Alison G. Watson. Attribution is encouraged, though not required.
 * See licenses/cc0.txt for more information.
 *
 * ---------------------------------------------------------------------------|
 *
 * The URANUS drawing system is essentially an instruction set with a
 * (very) simple state machine to draw stuff to the screen, either via ACS
 * or via ZScript. This is meant to replace HudMessage and allow a nicer,
 * unified drawing system between ZScript and ACS, usable by the playsim
 * while still providing maximum performance, as well as multiplayer compat.
 *
 * ---------------------------------------------------------------------------|
 */

enum Lith_DamageNumType {
   _dnum_smol,
   _dnum_norm,
   _dnum_crit,
   _dnum_max,
}

class Lith_DamageNum {
   vector3        m_origin;
   vector3        m_lastOrigin;
   int            m_damage;
   int            m_ticks;
   int            m_origTick;
   Lith_DamageNum m_next;
}

extend class Lith_URANUS;

/* Types ------------------------------------------------------------------- */

enum DrawType {
   _type_clipSet,
   _type_clipClear,
   _type_setSize,
   _type_line,
   _type_sprite,
   _type_spriteAlpha,
   _type_spriteStencil,
   _type_spriteStencilAlpha,
   _type_text,
   _type_textAlpha,
   _type_rect,
}

struct DrawData {
   uint8 type;

   uint8 cr;
   uint8 lnY;
   uint8 style;

   int16 x, y, z, w;

   color     c;
   textureId tex;
   double    a;

   Font          fnt;
   array<string> txt;
   array<int>    lnX;
}

struct FadeMsg {
   uint8 Fade;
   uint8 Time;
   uint8 FSub;
   uint8 Alph;
}

/* Members ----------------------------------------------------------------- */

private transient play DrawData[8000] m_D;
private transient play uint m_DPtr;
private transient play FadeMsg[256] m_FadeMsg;
private transient play vector2 m_VirtualSize;
private transient play int m_BreakWidth;
private transient play bool m_NoDraw;
private transient play bool m_ForceDraw;

private transient Font m_UtfBigFont;
private transient Font m_UtfTrmFont;
transient Font m_UtfFont;

private transient Shape2DTransform m_RectXf;
private transient Shape2D m_Rect;

private transient Lith_UTILHACK m_Uh;

private transient CVar m_CVarJpFont;
private transient CVar m_CVarXHairR;
private transient CVar m_CVarXHairG;
private transient CVar m_CVarXHairB;
private transient CVar m_CVarXHairA;
private transient CVar m_CVarXHairEnable;
private transient CVar m_CVarXHairStyle;
private transient CVar m_CVarXHairEnableJuicer;

transient bool m_English;

private transient bool m_dmgNumInit;
private transient int m_dmgNumAmount;
private transient Lith_DamageNum[_dnum_max] m_dmgNumHeads;

/* Static Functions -------------------------------------------------------- */

static void ForceDraw(bool on) {
   Lith_URANUS(Find("Lith_URANUS")).m_ForceDraw = on;
}

static void LZ(Actor mo, int w, int h) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return;

   let p = cl.m_DPtr;

   cl.m_D[p].Type = _type_setSize;

   cl.m_D[p].X = w;
   cl.m_D[p].Y = h;

   cl.m_DPtr++;

   cl.m_VirtualSize = (w, h);
}

static void LF(Actor mo, int fnum, int time, int speed, double alpha) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return;

   cl.m_FadeMsg[fnum].Time = time;
   cl.m_FadeMsg[fnum].FSub = speed;
   cl.m_FadeMsg[fnum].Alph = uint(alpha * 255.0);
   cl.m_FadeMsg[fnum].Fade = 255;
}

static bool LX(Actor mo, int num) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return false;
   return cl.m_FadeMsg[num].Fade > 0 && cl.m_FadeMsg[num].Alph > 0;
}

static int LY(Actor mo, int num) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return false;
   return int(cl.m_FadeMsg[num].Fade / 255.0 *
              cl.m_FadeMsg[num].Alph / 255.0 *
              255.0);
}

static void LL(Actor mo, int x, int y, int z, int w, color c = 0) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return;

   if(cl.m_NoDraw) return;
   let p = cl.m_DPtr;

   cl.m_D[p].Type = _type_line;

   [cl.m_D[p].X, cl.m_D[p].Y] = cl.GetScSized(x, y);
   [cl.m_D[p].Z, cl.m_D[p].W] = cl.GetScSized(z, w);

   cl.m_D[p].C = c;

   cl.m_DPtr++;
}

static void LS(Actor mo, string tex, int xx, int yy, double anum, int flags, color cr = 0) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return;
   if(cl.m_NoDraw) return;

   int  x  = xx & _xmask;
   int  y  = yy & _ymask;
   uint xa = xx & _xflag;
   uint ya = yy & _yflag;

   let p = cl.m_DPtr;

   if(flags & _u_fade) {
      cl.m_D[p].A  = cl.m_FadeMsg[uint(anum)].Fade / 255.0;
      cl.m_D[p].A *= cl.m_FadeMsg[uint(anum)].Alph / 255.0;
   } else if(flags & _u_alpha) {
      cl.m_D[p].A = anum;
   } else {
      cl.m_D[p].A = 1.0;
   }
   if(cl.m_D[p].A < 0.001) return;
   cl.m_D[p].Type = cl.m_D[p].A != 1.0 ? _type_spriteAlpha : _type_sprite;

   if(flags & _u_add)
      cl.m_D[p].Style = STYLE_Add;
   else if(cl.m_D[p].Type == _type_spriteAlpha)
      cl.m_D[p].Style = STYLE_Translucent;
   else
      cl.m_D[p].Style = STYLE_Normal;

   if(flags & _u_color) {
      if(cl.m_D[p].Type == _type_spriteAlpha)
         cl.m_D[p].Type = _type_spriteStencilAlpha;
      else
         cl.m_D[p].Type = _type_spriteStencil;
      cl.m_D[p].C = cr;
   }

   cl.m_D[p].Tex = getTextureForName(tex);

   int sx, sy; [sx, sy] = TexMan.GetSize(cl.m_D[p].Tex);

   switch(xa) {
      default:
      case _xl: cl.m_D[p].X = x;          break;
      case _xc: cl.m_D[p].X = x - sx / 2; break;
      case _xr: cl.m_D[p].X = x - sx;     break;
   }

   switch(ya) {
      default:
      case _yt: cl.m_D[p].Y = y;          break;
      case _yc: cl.m_D[p].Y = y - sy / 2; break;
      case _yb: cl.m_D[p].Y = y - sy;     break;
   }

   cl.m_DPtr++;
}

static void LT(Actor mo, string txt, string fnt, int xx, int yy, double anum, int cr, int flags) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return;
   if(cl.m_NoDraw) return;

   int  x  = xx & _xmask;
   int  y  = yy & _ymask;
   uint xa = xx & _xflag;
   uint ya = yy & _yflag;

   let p = cl.m_DPtr;

   if(flags & _u_fade) {
      cl.m_D[p].A  = cl.m_FadeMsg[uint(anum)].Fade / 255.0;
      cl.m_D[p].A *= cl.m_FadeMsg[uint(anum)].Alph / 255.0;
   } else if(flags & _u_alpha) {
      cl.m_D[p].A = anum;
   } else {
      cl.m_D[p].A = 1.0;
   }
   if(cl.m_D[p].A < 0.001) return;
   cl.m_D[p].Type = cl.m_D[p].A != 1.0 ? _type_textAlpha : _type_text;

   if(flags & _u_add)
      cl.m_D[p].Style = STYLE_Add;
   else if(cl.m_D[p].Type == _type_textAlpha)
      cl.m_D[p].Style = STYLE_Translucent;
   else
      cl.m_D[p].Style = STYLE_Normal;

   cl.m_D[p].Cr = cr;

   uint lns, lnx = 0;

   if(flags & _u_no_unicode || cl.m_English) {
      if(fnt == "smallfnt") cl.m_D[p].Fnt = smallfont;
      else                  cl.m_D[p].Fnt = Font.GetFont(fnt);
   } else {
      /**/ if(fnt == "bigupper") cl.m_D[p].Fnt = cl.m_UtfBigFont;
      else if(fnt == "ltrmfont") cl.m_D[p].Fnt = cl.m_UtfTrmFont;
      else                       cl.m_D[p].Fnt = cl.m_UtfFont;
      y += 2;
   }

   cl.m_D[p].LnY = cl.m_D[p].Fnt.GetHeight();
   let       brl = cl.m_D[p].Fnt.BreakLines(txt, cl.m_BreakWidth ? cl.m_BreakWidth : 0x7fff);

   lns = brl.Count();

   cl.m_D[p].Txt.Resize(lns);
   array<int> LnW;
   LnW.Resize(lns);

   for(uint i = 0, w; i < lns; i++) {
      cl.m_D[p].Txt[i] = brl.StringAt(i);
      LnW[i] = brl.StringWidth(i);

      if(lnx < (w = LnW[i])) lnx = w;
   }

   switch(xa) {
   default:
   case _x3:
   case _x4:
   case _xl: cl.m_D[p].X = x;           break;
   case _x5: cl.m_D[p].X = x + lnx / 2; break;
   case _x6:
   case _xc: cl.m_D[p].X = x - lnx / 2; break;
   case _xr: cl.m_D[p].X = x - lnx;     break;
   }

   switch(ya) {
   default:
   case _yt: cl.m_D[p].Y = y;                           break;
   case _yc: cl.m_D[p].Y = y - cl.m_D[p].LnY * lns / 2; break;
   case _yb: cl.m_D[p].Y = y - cl.m_D[p].LnY * lns;     break;
   }

   cl.m_D[p].LnX.Resize(lns);

   for(uint i = 0; i < lns; i++) {
           if(xa == _x3) cl.m_D[p].LnX[i] = LnW[i];
      else if(xa <  _x4) cl.m_D[p].LnX[i] = 0;
      else               cl.m_D[p].LnX[i] = LnW[i] / 2;
   }

   cl.m_DPtr++;
}

static void LC(Actor mo, int x = 0, int y = 0, int w = 0, int h = 0, int ww = 0) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return;

   let p = cl.m_DPtr;

   if(x || y || w || h) {
      /* simple optimization (which also prevents division by zero) */
      if((cl.m_NoDraw = w <= 0 || h <= 0)) return;

      cl.m_D[p].Type = _type_clipSet;

      [cl.m_D[p].X, cl.m_D[p].Y] = cl.GetScSized(x, y);
      [cl.m_D[p].Z, cl.m_D[p].W] = cl.GetScSized(w, h, true);
   } else {
      cl.m_NoDraw = false;
      cl.m_D[p].Type = _type_clipClear;
   }

   cl.m_BreakWidth = ww;
   cl.m_DPtr++;
}

static void LR(Actor mo, int x = 0, int y = 0, int w = 0, int h = 0, color cr = 0) {
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_ForceDraw && mo != Players[ConsolePlayer].Camera) return;

   if(cl.m_NoDraw) return;
   let p = cl.m_DPtr;

   cl.m_D[p].Type = _type_rect;

   [cl.m_D[p].X, cl.m_D[p].Y] = cl.GetScSized(x, y);
   [cl.m_D[p].Z, cl.m_D[p].W] = cl.GetScSized(w, h, true);

   cl.m_D[p].C = cr;

   cl.m_DPtr++;
}

static void LE() {
   let cl = Lith_URANUS(Find("Lith_URANUS"));

   cl.m_DPtr = 0;

   for(uint i = 0; i < cl.m_FadeMsg.Size(); i++) {
      if(cl.m_FadeMsg[i].Fade) {
         if(!cl.m_FadeMsg[i].Time) {
            cl.m_FadeMsg[i].Fade =
               Max(int(cl.m_FadeMsg[i].Fade) - int(cl.m_FadeMsg[i].FSub), 0);
         } else {
            cl.m_FadeMsg[i].Time--;
         }
      }
   }
}

static clearScope textureId getTextureForName(string tex) {
   for(int i = 0; tex.byteAt(0) == Ch_Colon; i++) {
      if(i > 5) {Console.printf("invalid texture: %s", tex); break;}
      tex = StringTable.Localize(tex, false);
   }

   return TexMan.CheckForTexture(tex, TexMan.Type_Any);
}

/* Member Functions -------------------------------------------------------- */

override void onRegister() {
   super.onRegister();

   projectRegister();

   PlayerInfo pl = players[consolePlayer];
   m_CVarJpFont = CVar.getCVar('lith_gui_jpfont', pl);
   m_CVarXHairR = CVar.getCVar('lith_xhair_r', pl);
   m_CVarXHairG = CVar.getCVar('lith_xhair_g', pl);
   m_CVarXHairB = CVar.getCVar('lith_xhair_b', pl);
   m_CVarXHairA = CVar.getCVar('lith_xhair_a', pl);
   m_CVarXHairEnable = CVar.getCVar('lith_xhair_enable', pl);
   m_CVarXHairStyle = CVar.getCVar('lith_xhair_style', pl);
   m_CVarXHairEnableJuicer = CVar.getCVar('lith_xhair_enablejuicer', pl);
}

override void worldLoaded(WorldEvent evt) {
   m_RectXf = new("Shape2DTransform");
   m_Rect = new("Shape2D");
   m_Rect.pushVertex((0, 0));
   m_Rect.pushVertex((1, 0));
   m_Rect.pushVertex((0, 1));
   m_Rect.pushVertex((1, 1));
   m_Rect.pushCoord((0, 0));
   m_Rect.pushCoord((1, 0));
   m_Rect.pushCoord((0, 1));
   m_Rect.pushCoord((1, 1));
   m_Rect.pushTriangle(0, 3, 1);
   m_Rect.pushTriangle(0, 2, 3);
}

override void worldTick() {
   if(!(m_English = StringTable.Localize("LITH_CHECK", false) == "Eng")) {
      switch(m_CVarJpFont.GetInt()) {
         default:
         case font_misaki_gothic: m_UtfFont = "MisakiG";  break;
         case font_misaki_mincho: m_UtfFont = "MisakiM";  break;
         case font_k6x8:          m_UtfFont = "k6x8";     break;
         case font_jiskan16:      m_UtfFont = "jiskan16"; break;
      }
      m_UtfBigFont = "newconsolefont";
      m_UtfTrmFont = "ljtrmfont";
   }

   projectSetRenderer();
   tickDmgNums();
}

override void renderOverlay(RenderEvent evt) {
   projectSetUp(evt);

   if(evt.camera && evt.camera.player) {
      drawDmgNums(evt);
      drawCrosshair(evt);
   }

   int scw = 320, sch = 240;

   if(!AutoMapActive) for(uint i = 0; i < m_DPtr; i++) switch(m_D[i].Type)
   {
   case _type_clipSet:
      Screen.SetClipRect(m_D[i].X, m_D[i].Y, m_D[i].Z, m_D[i].W);
      break;
   case _type_clipClear:
      Screen.ClearClipRect();
      break;
   case _type_setSize:
      scw = m_D[i].X;
      sch = m_D[i].Y;
      break;
   case _type_line:
      Screen.DrawLine(m_D[i].X, m_D[i].Y, m_D[i].Z, m_D[i].W, m_D[i].C);
      break;
   case _type_sprite:
      Screen.DrawTexture(m_D[i].Tex, false, m_D[i].X, m_D[i].Y,
                         DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                         DTA_TopOffset,0, DTA_LeftOffset,0,
                         DTA_LegacyRenderStyle,m_D[i].Style);
      break;
   case _type_spriteAlpha:
      Screen.DrawTexture(m_D[i].Tex, false, m_D[i].X, m_D[i].Y,
                         DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                         DTA_TopOffset,0, DTA_LeftOffset,0,
                         DTA_LegacyRenderStyle,m_D[i].Style,
                         DTA_Alpha,m_D[i].A);
      break;
   case _type_spriteStencil:
      Screen.DrawTexture(m_D[i].Tex, false, m_D[i].X, m_D[i].Y,
                         DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                         DTA_TopOffset,0, DTA_LeftOffset,0,
                         DTA_FillColor,m_D[i].C);
      break;
   case _type_spriteStencilAlpha:
      Screen.DrawTexture(m_D[i].Tex, false, m_D[i].X, m_D[i].Y,
                         DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                         DTA_TopOffset,0, DTA_LeftOffset,0,
                         DTA_Alpha,m_D[i].A, DTA_FillColor,m_D[i].C);
      break;
   case _type_text:
      for(uint ln = 0, lns = m_D[i].LnX.Size(); ln < lns; ln++)
         Screen.DrawText(m_D[i].Fnt, m_D[i].Cr,
                         m_D[i].X-m_D[i].LnX[ln], m_D[i].Y+m_D[i].LnY*ln,
                         m_D[i].Txt[ln],
                         DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                         DTA_LegacyRenderStyle,m_D[i].Style);
      break;
   case _type_textAlpha:
      for(uint ln = 0, lns = m_D[i].LnX.Size(); ln < lns; ln++)
         Screen.DrawText(m_D[i].Fnt, m_D[i].Cr,
                         m_D[i].X-m_D[i].LnX[ln], m_D[i].Y+m_D[i].LnY*ln,
                         m_D[i].Txt[ln],
                         DTA_VirtualWidth,scw, DTA_VirtualHeight,sch,
                         DTA_Alpha,m_D[i].A,
                         DTA_LegacyRenderStyle,m_D[i].Style);
      break;
   case _type_rect:
      m_RectXf.clear();
      m_RectXf.scale((m_D[i].Z, m_D[i].W));
      m_RectXf.translate((m_D[i].X, m_D[i].Y));
      m_Rect.setTransform(m_RectXf);
      Screen.DrawShape(skyflatnum, false, m_Rect, DTA_Alpha,m_D[i].C.a/255.0, DTA_FillColor,m_D[i].C);
      break;
   }

   let p = Lith_Player(evt.camera);
   if(p && p.m_Cs) p.m_Cs.Lith_Render();
}

clearScope int, int getScSized(double x, double y, bool kludge = false) {
   double vw = m_VirtualSize.X;
   double vh = m_VirtualSize.Y;

   double sw = Screen.GetWidth();
   double sh = Screen.GetHeight();

   vector2 xy, sc;

   if(kludge) [sc, xy] = Screen.VirtualToRealCoords((0, 0), ( x,  y), (vw, vh));
   else       [xy, sc] = Screen.VirtualToRealCoords((x, y), (sw, sh), (vw, vh));

   return int(xy.X), int(xy.Y);
}

void addDamageNum(vector3 pos, vector3 origin, double w, int damage) {
   if(CVar.getCVar('lith_hud_showdamage', players[consolePlayer]).getBool()) {
      if(!m_dmgNumInit) {
         for(int i = 0; i < _dnum_max; i++) {
            m_dmgNumHeads[i] = new("Lith_DamageNum");
         }
         m_dmgNumInit = true;
         m_dmgNumAmount = 0;
      }

      if(m_dmgNumAmount >= 1500) {
         return;
      }

      m_dmgNumAmount++;

      Lith_DamageNum start;

      if(damage >= 120) {
         start = m_dmgNumHeads[_dnum_crit];
      } else if(level.vec3Diff(pos, origin).length() > 1024) {
         start = m_dmgNumHeads[_dnum_smol];
      } else {
         start = m_dmgNumHeads[_dnum_norm];
      }

      let dnum = new("Lith_DamageNum");

      dnum.m_origin     = origin + (frandom(-w,w), frandom(-w,w), frandom(-9,9));
      dnum.m_lastOrigin = dnum.m_origin;
      dnum.m_damage     = damage;
      dnum.m_ticks      = 35 + min(damage, 120) / 3;
      dnum.m_origTick   = level.totalTime;
      dnum.m_next       = start.m_next;

      start.m_next = dnum;
   }
}

private void tickDmgNums() {
   for(Lith_DamageNumType ty = 0; ty < _dnum_max; ty++) {
      Lith_DamageNum start = m_dmgNumHeads[ty];
      if(!start) continue;

      Lith_DamageNum dnum = start.m_next, prev = null;
      while(dnum) {
         if(!dnum.m_ticks) {
            let next = dnum.m_next;
            if(prev) prev.m_next = next;
            dnum.destroy();
            dnum = next;
            m_dmgNumAmount--;
         } else {
            dnum.m_lastOrigin = dnum.m_origin;

            int speed = dnum.m_ticks / 5;

            if(speed != 0) {
               if(speed < 4) {
                  dnum.m_origin.z += 0.5;
               } else if(speed < 6) {
                  dnum.m_origin.z += 1.0;
               } else {
                  dnum.m_origin.z += 1.5;
               }
            }

            dnum.m_ticks--;

            prev = dnum;
            dnum = dnum.m_next;
         }
      }
   }
}

private ui void drawDmgNums(RenderEvent evt) {
   for(Lith_DamageNumType ty = 0; ty < _dnum_max; ty++) {
      Lith_DamageNum start = m_dmgNumHeads[ty];
      if(!start) continue;

      Lith_DamageNum dnum = start.m_next;
      while(dnum) {
         vector3 origin = Lith_UTIL.vec3Lerp(dnum.m_lastOrigin, dnum.m_origin, evt.fracTic);
         int x, y; bool seen; [x, y, seen] = project(origin);

         if(seen) {
            int cr;
            Font fnt;

            switch(ty) {
            case _dnum_smol: fnt = smallfont;  cr = Font.CR_GREY;  break;
            case _dnum_norm: fnt = "lmidfont"; cr = Font.CR_WHITE; break;
            case _dnum_crit: fnt = "bigupper"; cr = Font.CR_GOLD;  break;
            }

            let txt = string.format("%i", dnum.m_damage);

            double xf = x - fnt.stringWidth(txt) / 2.0;
            double yf = y - fnt.getHeight()      / 2.0;

            double a;
            if(dnum.m_ticks < 15) {
               a = dnum.m_ticks / 15.0;
               a -= (1.0 / 15.0) * evt.fracTic;
            } else {
               a = 1.0;
            }

            Screen.DrawText(fnt, cr, xf, yf, txt,
                            DTA_VirtualWidth,320, DTA_VirtualHeight,240,
                            DTA_Alpha,a,
                            DTA_LegacyRenderStyle,STYLE_Translucent);
         }

         dnum = dnum.m_next;
      }
   }
}

private ui void drawCrosshair(RenderEvent evt) {
   let pl = evt.camera;

   vector3 viewPos = (evt.viewPos.xy, evt.viewPos.z - lith_hermes.getViewHeight(pl) + lith_hermes.getAttackHeight(pl));

   double yaw   = evt.viewAngle + m_Uh.pData(pl, pdata_addy)/FIX;
   double pitch = evt.viewPitch + m_Uh.pData(pl, pdata_addp)/FIX;
   let loc = Lith_UTIL.traceFromPos(pl.curSector, viewPos, yaw, pitch, 2048.0, ignore: pl);

   vector2 xh;
   bool seen;
   [xh, seen] = projectF(loc);
   if(!seen) {
      return;
   }

   /* draw a tracer for the targeting system */
   let tr = pl.tracer;
   if(tr && tr.health > 0 &&
      m_Uh.pData(pl, pdata_weapon) == weapon_launcher)
   {
      int tr1x, tr1y, tr2x, tr2y;
      [tr1x, tr1y, seen] = project((tr.pos.xy, tr.pos.z + tr.height / 2.0));

      if(seen) {
         [tr1x, tr1y] = getScSized(tr1x, tr1y);
         [tr2x, tr2y] = getScSized(xh.x, xh.y);
         Screen.drawLine(tr1x, tr1y, tr2x, tr2y, "red");
      }
   }

   /* draw the crosshair */
   uint r = clamp(m_CVarXHairR.getInt(), 0, 255);
   uint g = clamp(m_CVarXHairG.getInt(), 0, 255);
   uint b = clamp(m_CVarXHairB.getInt(), 0, 255);
   uint a = clamp(m_CVarXHairA.getInt(), 0, 255);

   if(m_CVarXHairEnable.getBool() && a) {
      static const string[] XB_GFX = {
         ":XHairs:crossb",
         ":XHairs:circleb", ":XHairs:deltab",  ":XHairs:ovalb",
         ":XHairs:basicb",  ":XHairs:delearb", ":XHairs:finib",
         ":XHairs:angleb",  ":XHairs:dotb",    ":XHairs:xpb"
      };
      static const string[] XW_GFX = {
         ":XHairs:crossw",
         ":XHairs:circlew", ":XHairs:deltaw",  ":XHairs:ovalw",
         ":XHairs:basicw",  ":XHairs:delearw", ":XHairs:finiw",
         ":XHairs:anglew",  ":XHairs:dotw",    ":XHairs:xpw"
      };

      int style = m_CVarXHairStyle.getInt();
      if(style >= XW_GFX.size()) {
         style = 0;
      }

      textureId xhb = getTextureForName(XB_GFX[style]);
      textureId xhw = getTextureForName(XW_GFX[style]);
      color     c   = (r << 16) | (g << 8) | (b << 0);

      int bsx, bsy; [bsx, bsy] = TexMan.GetSize(xhb);
      int wsx, wsy; [wsx, wsy] = TexMan.GetSize(xhw);

      double xhx = xh.x - bsx/2.0;
      double xhy = xh.y - bsy/2.0;

      Screen.DrawTexture(xhb, false, xhx, xhy,
                         DTA_VirtualWidth,320, DTA_VirtualHeight,240,
                         DTA_TopOffset,0, DTA_LeftOffset,0,
                         DTA_Alpha,a/255.0);

      xhx = xh.x - wsx/2.0;
      xhy = xh.y - wsy/2.0;

      Screen.DrawTexture(xhw, false, xhx, xhy,
                         DTA_VirtualWidth,320, DTA_VirtualHeight,240,
                         DTA_TopOffset,0, DTA_LeftOffset,0,
                         DTA_Alpha,a/255.0,DTA_FillColor,c);

      if(m_CVarXHairEnableJuicer.getBool()) {
         textureId xhl = getTextureForName(":XHairs:L");
         textureId xhr = getTextureForName(":XHairs:R");

         int esx, esy; [esx, esy] = TexMan.GetSize(xhl);
         xhx = xh.x - esx/2.0;
         xhy = xh.y - esy/2.0;

         double xp = m_Uh.pData(pl, pdata_recoilp)/FIX * 500.0 + 10.0;

         Screen.DrawTexture(xhl, false, xhx-xp, xhy,
                            DTA_VirtualWidth,320, DTA_VirtualHeight,240,
                            DTA_TopOffset,0, DTA_LeftOffset,0,
                            DTA_Alpha,a/255.0,DTA_FillColor,c);
         Screen.DrawTexture(xhr, false, xhx+xp, xhy,
                            DTA_VirtualWidth,320, DTA_VirtualHeight,240,
                            DTA_TopOffset,0, DTA_LeftOffset,0,
                            DTA_Alpha,a/255.0,DTA_FillColor,c);
      }
   }
}

/* EOF */
