/*
   The URANUS drawing system is essentially an instruction set with a
   (very) simple state machine to draw stuff to the screen, either via ACS
   or via ZScript. This is meant to replace HudMessage and allow a nicer,
   unified drawing system between ZScript and ACS, usable by the playsim
   while still providing maximum performance, as well as multiplayer compat.
*/

extend class Lith_URANUS;

// Types ---------------------------------------------------------------------|

enum DrawType
{
   dt_lin,
   dt_tex,
   dt_ate,
   dt_cte,
   dt_xte,
   dt_txt,
   dt_utx,
   dt_cls,
   dt_clc,
   dt_siz,
}

struct DrawData
{
   uint8 dt;
   int16 x, y, z, w;

   textureid tex;
   color     c;
   float     a;

   uint8         cr;
   uint8         lny;
   Font          fnt;
   array<string> txt;
   array<int>    lnw;
   array<int>    lnx;
}

struct FadeMsg
{
   uint16 time;
   float  fsub;
   float  fade;
}

// Constants -----------------------------------------------------------------|

const font_space = 4;

const c_black     = 0x4d4d4d;
const c_blue      = 0x6e6eff;
const c_brick     = 0xeaadad;
const c_brown     = 0xcc9966;
const c_gold      = 0xffcc00;
const c_white     = 0xffffff;
const c_yellow    = 0xeeee32;
const c_tan       = 0xd2b48c;
const c_gray      = 0xc0c0c0;
const c_green     = 0x33ff33;
const c_red       = 0xff4e60;
const c_orange    = 0xffaa00;
const c_lightblue = 0x33eeff;
const c_cream     = 0xfecc99;
const c_olive     = 0xd1d8a7;
const c_darkgreen = 0x129a12;
const c_darkred   = 0xb22323;
const c_darkbrown = 0x6c5d56;
const c_purple    = 0xa674d7;
const c_darkgray  = 0x414141;
const c_cyan      = 0x00fffe;
const c_ice       = 0xafccd3;
const c_fire      = 0xfb7329;
const c_sapphire  = 0x6c729f;
const c_teal      = 0x8cd0dc;

// Members -------------------------------------------------------------------|

private transient play DrawData[400] m_d;
private transient play uint m_p;
private transient play FadeMsg[32] m_fmsg;
private transient play vector2 m_vsc;
private transient play int m_dww;
private transient play bool m_nodraw;
private transient play bool m_forcedraw;

bool m_fontloaded;
bool m_eng;

// Static Functions ----------------------------------------------------------|

static void ForceDraw(bool on)
{
   Lith_URANUS(Find("Lith_URANUS")).m_forcedraw = on;
}

static void LZ(Actor mo, int w, int h)
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_forcedraw && mo != players[consoleplayer].camera) return;

   let p = cl.m_p;

   cl.m_d[p].dt = dt_siz;

   cl.m_d[p].x = w;
   cl.m_d[p].y = h;

   cl.m_p++;

   cl.m_vsc = (w, h);
}

/* BIT LAYOUT OF ARGUMENTS

   0123 4567 8901 2345 6789 0123 4567 8901 OF SZ - DESCRIPTION

                                      arg0
   1111 1111 1111 1111 ---- ---- ---- ---- 16 16 - fade speed
   ---- ---- ---- ---- ---1 1111 11-- ----  6  7 - time (tics)
   ---- ---- ---- ---- ---- ---- --11 1111  0  6 - fade num
*/
static void LF(Actor mo, int arg0)
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_forcedraw && mo != players[consoleplayer].camera) return;

   uint num = arg0 & 0x3f;

   cl.m_fmsg[num].time = (arg0 >> 6) & 0x7f;
   cl.m_fmsg[num].fsub = float(arg0 >> 16) / 0xffff;
   cl.m_fmsg[num].fade = 1;
}

static bool LX(Actor mo, int num)
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_forcedraw && mo != players[consoleplayer].camera) return false;
   return cl.m_fmsg[num].fade != 0;
}

static void LL(Actor mo, int x, int y, int z, int w, string c = "")
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_forcedraw && mo != players[consoleplayer].camera) return;

   if(cl.m_nodraw) return;
   let p = cl.m_p;

   cl.m_d[p].dt = dt_lin;

   [cl.m_d[p].x, cl.m_d[p].y] = cl.getScSized(x, y);
   [cl.m_d[p].z, cl.m_d[p].w] = cl.getScSized(z, w);

   cl.m_d[p].c = c;

   cl.m_p++;
}

static void LS(Actor mo, string tex, int x, int y, int xa, int ya, double a = -1, string c = "")
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_forcedraw && mo != players[consoleplayer].camera) return;

   if(a ~== 0 || cl.m_nodraw) return;
   let p = cl.m_p;

   if(a < -1) a = cl.m_fmsg[uint(-a - 2)].fade;

   if(a == -1)
      cl.m_d[p].dt = dt_tex;
   else
   {
      if(a < 0.001) return;

      cl.m_d[p].dt = dt_ate;
      cl.m_d[p].a = a;
   }

   if(c != "")
   {
      if(cl.m_d[p].dt == dt_ate)
         cl.m_d[p].dt = dt_xte;
      else
         cl.m_d[p].dt = dt_cte;
      cl.m_d[p].c = c;
   }

   for(int i = 0; tex.charCodeAt(0) == Ch_Colon; i++)
   {
      if(i > 5) {Console.printf("invalid texture: %s", tex); break;}
      tex = StringTable.Localize(tex, false);
   }

   cl.m_d[p].tex = TexMan.CheckForTexture(tex, TexMan.Type_Any);

   int sx, sy; [sx, sy] = TexMan.GetSize(cl.m_d[p].tex);

   switch(xa) {
   default:
   case 1: cl.m_d[p].x = x;          break;
   case 0: cl.m_d[p].x = x - sx / 2; break;
   case 2: cl.m_d[p].x = x - sx;     break;
   }

   switch(ya) {
   default:
   case 1: cl.m_d[p].y = y;          break;
   case 0: cl.m_d[p].y = y - sy / 2; break;
   case 2: cl.m_d[p].y = y - sy;     break;
   }

   cl.m_p++;
}

/* BIT LAYOUT OF ARGUMENTS

   0123 4567 8901 2345 6789 0123 4567 8901 OF SZ - DESCRIPTION

                                      arg0
   1--- ---- ---- ---- ---- ---- ---- ---- 31  1 - "no unicode" flag
   -1-- ---- ---- ---- ---- ---- ---- ---- 30  1 - alpha flag
   --11 1111 ---- ---- ---- ---- ---- ---- 24  6 - alpha OR fade num
   ---- ---- ---- ---- ---- ---- 1111 1111  0  8 - color

                                      arg1
   1--- ---- ---- ---- ---- ---- ---- ---- 31  1 - X sign
   -1-- ---- ---- ---- ---- ---- ---- ---- 30  1 - Y sign
   ---- ---- 1111 1111 11-- ---- ---- ---- 14 10 - X position
   ---- ---- ---- ---- --11 1111 111- ----  5  9 - Y position
   ---- ---- ---- ---- ---- ---- ---1 11--  2  3 - X alignment
   ---- ---- ---- ---- ---- ---- ---- --11  0  2 - Y alignment
*/
static void LT(Actor mo, string txt, string fnt, int arg0, int arg1)
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_forcedraw && mo != players[consoleplayer].camera) return;

   bool af =  arg0        & 0x40000000;
   uint aa = (arg0 >> 24) & 0x3F;

   if((af && aa == 0) || cl.m_nodraw) return;

   int  x  = (arg1 >> 14) & 0x3FF;
   int  y  = (arg1 >>  5) & 0x1FF;
   uint xa = (arg1 >>  2) & 0x7;
   uint ya =  arg1        & 0x3;
   bool uf =  arg0        & 0x80000000;

   if(arg1 & 0x80000000) x = x - 0x400;
   if(arg1 & 0x40000000) y = y - 0x200;

   let p = cl.m_p;

   cl.m_d[p].a = !af && aa != 0 ? cl.m_fmsg[aa - 1].fade
                                : af ? aa ? float(aa) / 0x3F
                                          : 0.0
                                     : 1.0;
   cl.m_d[p].cr = arg0 & 0xff;

   uint lns, lnx = 0;

   if(uf || cl.m_eng)
   {
      cl.m_d[p].dt = dt_txt;

      cl.m_d[p].fnt = Font.GetFont(fnt);
      cl.m_d[p].lny = cl.m_d[p].fnt.getHeight();
      let       brl = cl.m_d[p].fnt.breakLines(txt, cl.m_dww ? cl.m_dww : 0x7fff);

      lns = brl.count();

      cl.m_d[p].txt.resize(lns);
      cl.m_d[p].lnw.resize(lns);

      for(uint i = 0, w; i < lns; i++)
      {
         cl.m_d[p].txt[i] = brl.stringAt(i);
         cl.m_d[p].lnw[i] = brl.stringWidth(i);

         if(lnx < (w = cl.m_d[p].lnw[i])) lnx = w;
      }
   }
   else
   {
      cl.m_d[p].dt = dt_utx;

      cl.m_d[p].lny = 8;

      array<string> brl;
      txt.split(brl, "\n");
      let lnum = brl.size();

      cl.m_d[p].txt.clear();
      cl.m_d[p].lnw.clear();

      for(uint i = 0; i < lnum; i++)
      {
         uint w = 0;
         uint pos, sta, len;

         for(pos = 0, sta = 0, len = brl[i].length(); pos < len;)
         {
            let str = brl[i];
            uint uclen, ucp; [uclen, ucp] = Utf32AtUtf8(str, pos);
            pos += uclen;

            if(ucp == Ch_Color)
            {
               name _; [_, pos] = ParseColor(str, pos);
               continue;
            }

            uint ww;

            if(ucp == Ch_Space)
               ww = font_space;
            else
            {
               let metr = CallACS("Lith_GetFontMetric", ucp);
               let xadv = CallACS("Lith_Metr_Xadv", metr);
               ww = xadv;
            }

            if(w + ww > (cl.m_dww ? cl.m_dww : 0x7fff))
            {
               if(ucp != Ch_Space) pos -= uclen;

               cl.m_d[p].txt.push(brl[i].mid(sta, pos - sta));
               cl.m_d[p].lnw.push(w);

               if(lnx < w) lnx = w;

               sta = pos;
               w = 0;
            }
            else
               w += ww;
         }

         cl.m_d[p].txt.push(brl[i].mid(sta, pos - sta));
         cl.m_d[p].lnw.push(w);

         if(lnx < w) lnx = w;
      }

      lns = cl.m_d[p].txt.size();
   }

   switch(xa) {
   default:
   case 3:
   case 4:
   case 1: cl.m_d[p].x = x;           break;
   case 5: cl.m_d[p].x = x + lnx / 2; break;
   case 6:
   case 0: cl.m_d[p].x = x - lnx / 2; break;
   case 2: cl.m_d[p].x = x - lnx;     break;
   }

   switch(ya) {
   default:
   case 1: cl.m_d[p].y = y;                           break;
   case 0: cl.m_d[p].y = y - cl.m_d[p].lny * lns / 2; break;
   case 2: cl.m_d[p].y = y - cl.m_d[p].lny * lns;     break;
   }

   cl.m_d[p].lnx.resize(lns);

   for(uint i = 0; i < lns; i++) {
           if(xa == 3) cl.m_d[p].lnx[i] = cl.m_d[p].lnw[i];
      else if(xa <  4) cl.m_d[p].lnx[i] = 0;
      else             cl.m_d[p].lnx[i] = cl.m_d[p].lnw[i] / 2;
   }

   cl.m_p++;
}

/* BIT LAYOUT OF ARGUMENTS

   0123 4567 8901 2345 6789 0123 4567 8901 OF SZ - DESCRIPTION

                                      arg0
   1111 1111 1111 1111 ---- ---- ---- ---- 16 16 - Y position
   ---- ---- ---- ---- 1111 1111 1111 1111  0 16 - X position

                                      arg1
   1111 1111 1111 1111 ---- ---- ---- ---- 16 16 - height
   ---- ---- ---- ---- 1111 1111 1111 1111  0 16 - width

                                      arg2
   ---- ---- ---- ---- 1111 1111 1111 1111  0 16 - wrap width
*/
static void LC(Actor mo, int arg0 = 0, int arg1 = 0, int arg2 = 0)
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));
   if(!cl.m_forcedraw && mo != players[consoleplayer].camera) return;

   let p = cl.m_p;

   if(arg0 || arg1)
   {
      uint x =  arg0        & 0xffff;
      uint y = (arg0 >> 16) & 0xffff;
      uint w =  arg1        & 0xffff;
      uint h = (arg1 >> 16) & 0xffff;

      // simple optimization (which also prevents division by zero)
      if((cl.m_nodraw = w <= 0 || h <= 0)) return;

      cl.m_d[p].dt = dt_cls;

      [cl.m_d[p].x, cl.m_d[p].y] = cl.getScSized(x, y);
      [cl.m_d[p].z, cl.m_d[p].w] = cl.getScSized(w, h, true);
   }
   else
   {
      cl.m_nodraw = false;
      cl.m_d[p].dt = dt_clc;
   }

   cl.m_dww = arg2;
   cl.m_p++;
}

static void LE()
{
   let cl = Lith_URANUS(Find("Lith_URANUS"));

   cl.m_p = 0;

   for(uint i = 0; i < cl.m_fmsg.size(); i++)
   {
      if(!cl.m_fmsg[i].fade)
         continue;
      else if(!cl.m_fmsg[i].time)
         cl.m_fmsg[i].fade = max(cl.m_fmsg[i].fade - cl.m_fmsg[i].fsub, 0);
      else
         cl.m_fmsg[i].time--;
   }
}

static int LTArgsN(uint x, uint y, uint xa, uint ya)
{
   return (x << 14) | (y << 5) | (xa << 2) | ya;
}

static int LTArgsA(uint x, uint y, uint xa, uint ya, float a)
{
   return LTArgsN(x, y, xa, ya) | 0x40000000 | (uint(a * 0x3F) << 24);
}

static clearscope uint, uint Utf32AtUtf8(string str, uint pos)
{
   // Copyright (c) 2018 Benjamin Moir. All rights reserved.
   // This work is licensed under the terms of the MIT license.
   // To obtain a copy, visit <https://opensource.org/licenses/MIT>.
   uint len, b0 = str.charCodeAt(pos) & 0xff, b1, b2, b3;

        if(b0 < 0x80) len = 1;
   else if(b0 < 0xe0) len = 2;
   else if(b0 < 0xf0) len = 3;
   else               len = 4;

   switch(len) {
   case 4: b3 = str.charCodeAt(pos + 3) & 0xff;
   case 3: b2 = str.charCodeAt(pos + 2) & 0xff;
   case 2: b1 = str.charCodeAt(pos + 1) & 0xff;
   case 1: break;
   }

   switch(len) {
   default:
   case 1: return len,  b0;
   case 2: return len, (b0 - 0xc0) << 6  | (b1 - 0x80);
   case 3: return len, (b0 - 0xe0) << 12 | (b1 - 0x80) << 6  | (b2 - 0x80);
   case 4: return len, (b0 - 0xf0) << 18 | (b1 - 0x80) << 12 | (b2 - 0x80) << 6 | (b3 - 0x80);
   }
}

static clearscope name, uint ParseColor(string str, uint pos)
{
   if(str.charCodeAt(pos) == Ch_BrackO)
   {
      uint sta = pos;
      while(str.charCodeAt(++pos) != Ch_BrackC);
      return str.mid(sta, pos - sta), pos;
   }
   else
      return str.charAt(pos++), pos;
}

static int GetTex(string gfx)
{
   return int(TexMan.CheckForTexture(gfx, TexMan.Type_Any));
}

static int GetTexW(int gfx_)
{
   if(gfx_ < 0) return 0;
   textureid gfx; gfx.setNull(); gfx += gfx_;
   int w, h; [w, h] = TexMan.GetSize(gfx);
   return w;
}

static int GetTexH(int gfx_)
{
   if(gfx_ < 0) return 0;
   textureid gfx; gfx.setNull(); gfx += gfx_;
   int w, h; [w, h] = TexMan.GetSize(gfx);
   return h;
}

// Member Functions ----------------------------------------------------------|

override void WorldLoaded(WorldEvent evt)
{
   if(m_fontloaded) return;

   // Unfortunately, due to the script runaway limit in ACS, we need to do this
   // here so everything is initialized without breaking.
   for(int fontnum = 0;; fontnum++)
   {
      if(!CallACS("Lith_SetupFontsBegin", fontnum)) break;
      while(CallACS("Lith_SetupFontsContinue"));
   }

   m_fontloaded = true;
}

override void WorldTick()
{
   if(!(m_eng = StringTable.Localize("LITH_CHECK", false) == "Eng"))
      CallACS("Lith_SetFontFace",
         CVar.GetCVar('lith_gui_jpfont', players[consoleplayer]).getInt());
}

override void RenderOverlay(RenderEvent evt)
{
   int scw = 320, sch = 240;

   if(!automapactive) for(uint i = 0; i < m_p; i++) switch(m_d[i].dt)
   {
   case dt_lin:
      Screen.DrawLine(m_d[i].x, m_d[i].y, m_d[i].z, m_d[i].w, m_d[i].c);
      break;
   case dt_tex:
      Screen.DrawTexture(m_d[i].tex, false, m_d[i].x, m_d[i].y,
         DTA_VirtualWidth, scw, DTA_VirtualHeight, sch, DTA_TopOffset,0,DTA_LeftOffset,0);
      break;
   case dt_ate:
      Screen.DrawTexture(m_d[i].tex, false, m_d[i].x, m_d[i].y,
         DTA_VirtualWidth, scw, DTA_VirtualHeight, sch, DTA_TopOffset,0,DTA_LeftOffset,0,
         DTA_Alpha, m_d[i].a);
      break;
   case dt_cte:
      Screen.DrawTexture(m_d[i].tex, false, m_d[i].x, m_d[i].y,
         DTA_VirtualWidth, scw, DTA_VirtualHeight, sch, DTA_TopOffset,0,DTA_LeftOffset,0,
         DTA_FillColor, m_d[i].c);
      break;
   case dt_xte:
      Screen.DrawTexture(m_d[i].tex, false, m_d[i].x, m_d[i].y,
         DTA_VirtualWidth, scw, DTA_VirtualHeight, sch, DTA_TopOffset,0,DTA_LeftOffset,0,
         DTA_Alpha, m_d[i].a,
         DTA_FillColor, m_d[i].c);
      break;
   case dt_txt:
      for(uint ln = 0, lns = m_d[i].lnx.size(); ln < lns; ln++)
         Screen.DrawText(m_d[i].fnt, m_d[i].cr,
            m_d[i].x-m_d[i].lnx[ln], m_d[i].y+m_d[i].lny*ln, m_d[i].txt[ln],
            DTA_VirtualWidth, scw, DTA_VirtualHeight, sch,
            DTA_Alpha, m_d[i].a);
      break;
   case dt_utx:
   {
      uint defcr;
      switch(m_d[i].cr) {
      case Font.CR_BLACK:     defcr = c_black;     break;
      case Font.CR_BLUE:      defcr = c_blue;      break;
      case Font.CR_BRICK:     defcr = c_brick;     break;
      case Font.CR_BROWN:     defcr = c_brown;     break;
      case Font.CR_CREAM:     defcr = c_cream;     break;
      case Font.CR_CYAN:      defcr = c_cyan;      break;
      case Font.CR_DARKBROWN: defcr = c_darkbrown; break;
      case Font.CR_DARKGRAY:  defcr = c_darkgray;  break;
      case Font.CR_DARKGREEN: defcr = c_darkgreen; break;
      case Font.CR_DARKRED:   defcr = c_darkred;   break;
      case Font.CR_FIRE:      defcr = c_fire;      break;
      case Font.CR_GOLD:      defcr = c_gold;      break;
      case Font.CR_GREEN:     defcr = c_green;     break;
      case Font.CR_GRAY:      defcr = c_gray;      break;
      case Font.CR_ICE:       defcr = c_ice;       break;
      case Font.CR_LIGHTBLUE: defcr = c_lightblue; break;
      case Font.CR_OLIVE:     defcr = c_olive;     break;
      case Font.CR_ORANGE:    defcr = c_orange;    break;
      case Font.CR_PURPLE:    defcr = c_purple;    break;
      case Font.CR_RED:       defcr = c_red;       break;
      case Font.CR_SAPPHIRE:  defcr = c_sapphire;  break;
      case Font.CR_TAN:       defcr = c_tan;       break;
      case Font.CR_TEAL:      defcr = c_teal;      break;
      default:
      case Font.CR_UNTRANSLATED:
      case Font.CR_WHITE:     defcr = c_white;     break;
      case Font.CR_YELLOW:    defcr = c_yellow;    break;
      }

      uint cr = defcr;
      for(uint ln = 0, lns = m_d[i].lnx.size(), y = m_d[i].y + m_d[i].lny; ln < lns; ln++)
      {
         int x = m_d[i].x - m_d[i].lnx[ln];
         int xo = x;

         for(uint pos = 0, len = m_d[i].txt[ln].length(); pos < len;)
         {
            let str = m_d[i].txt[ln];
            uint uclen, ucp; [uclen, ucp] = Utf32AtUtf8(str, pos);
            pos += uclen;

            if(ucp == Ch_Color)
            {
               name colo; [colo, pos] = ParseColor(str, pos);

               switch(colo) {
               default:
               case 'a': cr = c_brick;     break;
               case 'b': cr = c_tan;       break;
               case 'c': cr = c_gray;      break;
               case 'd': cr = c_green;     break;
               case 'e': cr = c_brown;     break;
               case 'f': cr = c_gold;      break;
               case 'g': cr = c_red;       break;
               case 'h': cr = c_blue;      break;
               case 'i': cr = c_orange;    break;
               case 'j': cr = c_white;     break;
               case 'k': cr = c_yellow;    break;
               case '-':
               case 'l': cr = defcr;       break;
               case 'm': cr = c_black;     break;
               case 'n': cr = c_lightblue; break;
               case 'o': cr = c_cream;     break;
               case 'p': cr = c_olive;     break;
               case 'q': cr = c_darkgreen; break;
               case 'r': cr = c_darkred;   break;
               case 's': cr = c_darkbrown; break;
               case 't': cr = c_purple;    break;
               case 'u': cr = c_darkgray;  break;
               case 'v': cr = c_cyan;      break;
               case 'w': cr = c_ice;       break;
               case 'x': cr = c_fire;      break;
               case 'y': cr = c_sapphire;  break;
               case 'z': cr = c_teal;      break;
               case '[Lith_Blue]':   cr = 0x3b47f8; break;
               case '[Lith_Green]':  cr = 0x00ff00; break;
               case '[Lith_Grey]':   cr = 0xbfbfbf; break;
               case '[Lith_Purple]': cr = 0x8c3bf8; break;
               case '[Lith_Red]':    cr = 0xbf0f4a; break;
               }
            }
            else if(ucp == Ch_Space)
               x += font_space;
            else
            {
               int metr = CallACS("Lith_GetFontMetric", ucp);
               int gfx_ = CallACS("Lith_Metr_Tex", metr);
               if(gfx_ < 0) continue;

               textureid gfx; gfx.setNull(); gfx += gfx_;

               if(gfx.isValid())
               {
                  let xadv = CallACS("Lith_Metr_Xadv", metr);
                  let yofs = CallACS("Lith_Metr_Yofs", metr);

                  Screen.DrawTexture(gfx, false, x, y-yofs,
                     DTA_VirtualWidth, scw, DTA_VirtualHeight, sch,
                     DTA_Alpha, m_d[i].a, DTA_AlphaChannel, true,
                     DTA_FillColor, cr);

                  if(x + xadv > scw)
                  {
                     y += m_d[i].lny;
                     x = xo;

                     for(;;)
                     {
                        [uclen, ucp] = Utf32AtUtf8(str, pos);
                        if(ucp != Ch_Space) break;
                        pos += uclen;
                     }
                  }
                  else
                     x += xadv;
               }
            }
         }

         y += m_d[i].lny;
      }
      break;
   }
   case dt_cls:
      Screen.SetClipRect(m_d[i].x, m_d[i].y, m_d[i].z, m_d[i].w);
      break;
   case dt_clc:
      Screen.ClearClipRect();
      break;
   case dt_siz:
      scw = m_d[i].x;
      sch = m_d[i].y;
      break;
   }

   let p = Lith_Player(evt.camera);
   if(p && p.m_cs) p.m_cs.Lith_Render();
}

float, float GetScSized(float x, float y, bool kludge = false)
{
   float vw = m_vsc.x;
   float vh = m_vsc.y;

   float sw = Screen.GetWidth();
   float sh = Screen.GetHeight();

   vector2 xy, sc;

   if(kludge) [sc, xy] = Screen.VirtualToRealCoords((0, 0), ( x,  y), (vw, vh));
   else       [xy, sc] = Screen.VirtualToRealCoords((x, y), (sw, sh), (vw, vh));

   return xy.x, xy.y;
}

// EOF
